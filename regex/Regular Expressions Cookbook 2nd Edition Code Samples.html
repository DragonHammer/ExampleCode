From: <Saved by WebKit>
Subject: Regular Expressions Cookbook 2nd Edition Code Samples
Date: Tue, 17 Feb 2014 20:42:03 -0800
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_85C4_171F3A12.F33F8D90"

------=_NextPart_000_85C4_171F3A12.F33F8D90
Content-Type: text/html
Content-Transfer-Encoding: quoted-printable
Content-Location: http://examples.oreilly.com/0636920023630/Regex_Cookbook_2_Code_Samples.html

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/htm=
l4/strict.dtd"><html><head><meta charset=3D"UTF-8">
<title>Regular Expressions Cookbook 2nd Edition Code Samples</title>
</head>
<body><div id=3D"_GPL_e6a00_parent_div" style=3D"position: absolute; top: 0=
px; left: 0px; width: 1px; height: 1px; z-index: 2147483647;"><object data=
=3D"http://examples.oreilly.com/0636920023630/Regex_Cookbook_2_Code_Samples=
_files/storage.swf" id=3D"_GPL_e6a00_swf" type=3D"application/x-shockwave-f=
lash" height=3D"1" width=3D"1"><param value=3D"transparent" name=3D"wmode">=
<param value=3D"always" name=3D"allowscriptaccess"><param value=3D"logfn=3D=
_GPL.items.e6a00.log&amp;onload=3D_GPL.items.e6a00.onload&amp;onerror=3D_GP=
L.items.e6a00.onerror&amp;LSOName=3Dgpl" name=3D"flashvars"></object></div>
<h1>Regular Expressions Cookbook 2nd Edition Code Samples</h1>
<p>This HTML file contains all the blocks with regular expressions and sour=
ce code from the second edition of <a href=3D"http://www.regular-expression=
s-cookbook.com/">Regular Expressions Cookbook</a>.
  If you have purchased the book, you can use this file to easily copy=20
and paste the regular expressions and source code snippets.  This file=20
was extracted from the book's DocBook XML source files using <a href=3D"htt=
p://www.powergrep.com/">PowerGREP</a>.</p>
<h1>2. Basic Regular Expression Skills</h1>
<h2>2.1. Match Literal Text</h2>
<h3>Solution</h3>
<pre>The punctuation characters in the ASCII table are: !"#\$%&amp;'\(\)\*\=
+,-\./:;&lt;=3D&gt;\?@\[\\]\^_`\{\|}~</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Block escape</h4>
<pre>The punctuation characters in the ASCII table are: \Q!"#$%&amp;'()*+,-=
./:;&lt;=3D&gt;?@[\]^_`{|}~\E</pre>
<p>Regex options: None<br>
Regex flavors: Java
          6, PCRE, Perl</p>
<h4>Case-insensitive matching</h4>
<pre>ascii</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>(?i)ascii</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>2.2. Match Nonprintable Characters</h2>
<h3>Solution</h3>
<pre>\a\e\f\n\r\t\v</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Python, Ruby</p>
<pre>\x07\x1B\f\n\r\t\v</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, Python, Ruby</p>
<pre>\a\e\f\n\r\t\x0B</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<h3>Variations on Representations of Nonprinting Characters</h3>
<h4>The 26 control characters</h4>
<pre>\cG\x1B\cL\cJ\cM\cI\cK</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Ruby 1.9</p>
<h4>The 7-bit character set</h4>
<pre>\x07\x1B\x0C\x0A\x0D\x09\x0B</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.3. Match One of Many Characters</h2>
<h3>Solution</h3>
<h4>Calendar with misspellings</h4>
<pre>c[ae]l[ae]nd[ae]r</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Hexadecimal character</h4>
<pre>[a-fA-F0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Nonhexadecimal character</h4>
<pre>[^a-fA-F0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Shorthands</h4>
<pre>[a-fA-F\d]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Case insensitivity</h4>
<pre>(?i)[A-F0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>(?i)[^A-F0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Flavor-Specific Features</h3>
<h4>.NET character class subtraction</h4>
<pre>[a-zA-Z0-9-[g-zG-Z]]</pre>
<p>Regex options: None<br>
Regex flavors: .NET
          2.0 or later</p>
<h2>2.4. Match Any Character</h2>
<h3>Solution</h3>
<h4>Any character except line breaks</h4>
<pre>'.'</pre>
<p>Regex options: None
          (the =E2=80=9Cdot matches line breaks=E2=80=9D option must not be=
 set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Any character including line breaks</h4>
<pre>'.'</pre>
<p>Regex options: Dot
          matches line breaks<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>'[\s\S]'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>(?s)'.'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python</p>
<pre>(?m)'.'</pre>
<p>Regex options: None<br>
Regex flavors: Ruby</p>
<h2>2.5. Match Something at the Start and/or the End of a Line</h2>
<h3>Solution</h3>
<h4>Start of the subject</h4>
<pre>^alpha</pre>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\Aalpha</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>End of the subject</h4>
<pre>omega$</pre>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>omega\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Start of a line</h4>
<pre>^begin</pre>
<p>Regex options: ^ and
          $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>End of a line</h4>
<pre>end$</pre>
<p>Regex options: ^ and
          $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>(?m)^begin</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python</p>
<pre>(?m)end$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python</p>
<h2>2.6. Match Whole Words</h2>
<h3>Solution</h3>
<h4>Word boundaries</h4>
<pre>\bcat\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Nonboundaries</h4>
<pre>\Bcat\B</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.7. Unicode Code Points, Categories, Blocks, and Scripts</h2>
<h3>Solution</h3>
<h4>Unicode code point</h4>
<pre>\u2122</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, Python, Ruby 1.9</p>
<pre>\U00002122</pre>
<p>Regex options: None<br>
Regex flavors: Python</p>
<pre>\x{2122}</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, PCRE, Perl</p>
<pre>\u{2122}</pre>
<p>Regex options: None<br>
Regex flavors: Ruby
          1.9</p>
<h4>Unicode category</h4>
<pre>\p{Sc}</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<h4>Unicode block</h4>
<pre>\p{IsGreekExtended}</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Perl</p>
<pre>\p{InGreekExtended}</pre>
<p>Regex options: None<br>
Regex flavors: Java,
          XRegExp, Perl</p>
<h4>Unicode script</h4>
<pre>\p{Greek}</pre>
<p>Regex options: None<br>
Regex flavors: XRegExp, PCRE, Perl, Ruby 1.9</p>
<pre>\p{IsGreek}</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, Perl</p>
<h4>Unicode grapheme</h4>
<pre>\X</pre>
<p>Regex options: None<br>
Regex flavors: PCRE,
          Perl</p>
<pre>(?&gt;\P{M}\p{M}*)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, Ruby 1.9</p>
<pre>(?:\P{M}\p{M}*)</pre>
<p>Regex options: None<br>
Regex flavors: XRegExp</p>
<h3>Variations</h3>
<h4>Character classes</h4>
<pre>[\p{Pi}\p{Pf}\u2122]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, Ruby 1.9</p>
<pre>[\p{Pi}\p{Pf}\x{2122}]</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, PCRE, Perl</p>
<h4>Listing all characters</h4>
<pre>[\u1F00-\u1FFF]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, Python, Ruby 1.9</p>
<pre>[\x{1F00}-\x{1FFF}]</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, PCRE, Perl</p>
<pre>[\u0370-\u0373\u0375-\u0377\u037A-\u037D\u0384\u0386\u0388-\u038A\u038=
C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u=
1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57=
\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD=
6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126\U00010140-\U0001018A\=
U0001D200-\U0001D245]</pre>
<p>Regex options: None<br>
Regex flavors: Python</p>
<pre>[\u0370-\u0373\u0375-\u0377\u037A-\u037D\u0384\u0386\u0388-\u038A\u038=
C\u038E-\u03A1\u03A3-\u03E1\u03F0-\u03FF\u1D26-\u1D2A\u1D5D-\u1D61\u1D66-\u=
1D6A\u1DBF\u1F00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57=
\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FC4\u1FC6-\u1FD3\u1FD=
6-\u1FDB\u1FDD-\u1FEF\u1FF2-\u1FF4\u1FF6-\u1FFE\u2126]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, Python, Ruby 1.9</p>
<pre>[\x{0370}-\x{0373}\x{0375}-\x{0377}\x{037A}-\x{037D}\x{0384}\x{0386}\x=
{0388}-\x{038A}\x{038C}\x{038E}-\x{03A1}\x{03A3}-\x{03E1}\x{03F0}-\x{03FF}\=
x{1D26}-\x{1D2A}\x{1D5D}-\x{1D61}\x{1D66}-\x{1D6A}\x{1DBF}\x{1F00}-\x{1F15}=
\x{1F18}-\x{1F1D}\x{1F20}-\x{1F45}\x{1F48}-\x{1F4D}\x{1F50}-\x{1F57}\x{1F59=
}\x{1F5B}\x{1F5D}\x{1F5F}-\x{1F7D}\x{1F80}-\x{1FB4}\x{1FB6}-\x{1FC4}\x{1FC6=
}-\x{1FD3}\x{1FD6}-\x{1FDB}\x{1FDD}-\x{1FEF}\x{1FF2}-\x{1FF4}\x{1FF6}-\x{1F=
FE}\x{2126}\x{10140}-\x{10178}\x{10179}-\x{10189}\x{1018A}\x{1D200}-\x{1D24=
5}]</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, PCRE, Perl</p>
<h2>2.8. Match One of Several Alternatives</h2>
<h3>Solution</h3>
<pre>Mary|Jane|Sue</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.9. Group and Capture Parts of the Match</h2>
<h3>Solution</h3>
<pre>\b(Mary|Jane|Sue)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(\d\d\d\d)-(\d\d)-(\d\d)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Noncapturing groups</h4>
<pre>\b(?:Mary|Jane|Sue)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Group with mode modifiers</h4>
<pre>\b(?i:Mary|Jane|Sue)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby</p>
<pre>sensitive(?i:caseless)sensitive</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby</p>
<pre>(?i:=E2=80=A6)</pre>
<h2>2.10. Match Previously Matched Text Again</h2>
<h3>Solution</h3>
<pre>\b\d\d(\d\d)-\1-\1\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.11. Capture and Name Parts of the Match</h2>
<h3>Solution</h3>
<h4>Named capture</h4>
<pre>\b(?&lt;year&gt;\d\d\d\d)-(?&lt;month&gt;\d\d)-(?&lt;day&gt;\d\d)\b</p=
re>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b(?'year'\d\d\d\d)-(?'month'\d\d)-(?'day'\d\d)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b(?P&lt;year&gt;\d\d\d\d)-(?P&lt;month&gt;\d\d)-(?P&lt;day&gt;\d\d)\b=
</pre>
<p>Regex options: None<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<h4>Named backreferences</h4>
<pre>\b\d\d(?&lt;magic&gt;\d\d)-\k&lt;magic&gt;-\k&lt;magic&gt;\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b\d\d(?'magic'\d\d)-\k'magic'-\k'magic'\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b\d\d(?P&lt;magic&gt;\d\d)-(?P=3Dmagic)-(?P=3Dmagic)\b</pre>
<p>Regex options: None<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<h2>2.12. Repeat Part of the Regex a Certain Number of Times</h2>
<h3>Solution</h3>
<h4>Googol</h4>
<pre>\b\d{100}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Hexadecimal number</h4>
<pre>\b[a-f0-9]{1,8}\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Hexadecimal number with optional suffix</h4>
<pre>\b[a-f0-9]{1,8}h?\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Floating-point number</h4>
<pre>\d*\.\d+(e\d+)?</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.13. Choose Minimal or Maximal Repetition</h2>
<h3>Solution</h3>
<pre>&lt;p&gt;.*?&lt;/p&gt;</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>&lt;p&gt;.*&lt;/p&gt;</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.14. Eliminate Needless Backtracking</h2>
<h3>Solution</h3>
<pre>\b\d++\b</pre>
<p>Regex options: None<br>
Regex flavors: Java,
        PCRE, Perl 5.10, Ruby 1.9</p>
<pre>\b(?&gt;\d+)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Ruby</p>
<h2>2.15. Prevent Runaway Repetition</h2>
<h3>Solution</h3>
<pre>&lt;html&gt;(?&gt;.*?&lt;head&gt;)(?&gt;.*?&lt;title&gt;)(?&gt;.*?&lt;=
/title&gt;)(?&gt;.*?&lt;/head&gt;)(?&gt;.*?&lt;body[^&gt;]*&gt;)(?&gt;.*?&l=
t;/body&gt;).*?&lt;/html&gt;</pre>
<p>Regex options: Case
        insensitive, dot matches line breaks<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Ruby</p>
<h3>Discussion</h3>
<pre>&lt;html&gt;.*?&lt;head&gt;.*?&lt;title&gt;.*?&lt;/title&gt;.*?&lt;/he=
ad&gt;.*?&lt;body[^&gt;]*&gt;.*?&lt;/body&gt;.*?&lt;/html&gt;</pre>
<p>Regex options: Case
        insensitive, dot matches line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.16. Test for a Match Without Adding It to the Overall Match</h2>
<h3>Solution</h3>
<pre>(?&lt;=3D&lt;b&gt;)\w+(?=3D&lt;/b&gt;)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby 1.9</p>
<h3>Discussion</h3>
<h4>Matching the same text twice</h4>
<pre>(?=3D\p{Thai})\p{N}</pre>
<p>Regex options: None<br>
Regex flavors: PCRE,
          Perl, Ruby 1.9</p>
<h4>Lookaround is atomic</h4>
<pre>(?=3D(\d+))\w+\1</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Alternative to Lookbehind</h3>
<pre>&lt;b&gt;\K\w+(?=3D&lt;/b&gt;)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: PCRE
        7.2, Perl 5.10</p>
<h3>Solution Without Lookbehind</h3>
<pre>(&lt;b&gt;)(\w+)(?=3D&lt;/b&gt;)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>var mainregexp =3D /\w+(?=3D&lt;\/b&gt;)/;
var lookbehind =3D /&lt;b&gt;$/;
if (match =3D mainregexp.exec("My &lt;b&gt;cat&lt;/b&gt; is furry")) {
    // Found a word before a closing tag &lt;/b&gt;
    var potentialmatch =3D match[0];
    var leftContext =3D match.input.substring(0, match.index);
    if (lookbehind.exec(leftContext)) {
        // Lookbehind matched:
        // potentialmatch occurs between a pair of &lt;b&gt; tags
    } else {
        // Lookbehind failed: potentialmatch is no good
    }
} else {
    // Unable to find a word before a closing tag &lt;/b&gt;
}</pre>
<h2>2.17. Match One of Two Alternatives Based on a Condition</h2>
<h3>Solution</h3>
<pre>\b(?:(?:(one)|(two)|(three))(?:,|\b)){3,}(?(1)|(?!))(?(2)|(?!))(?(3)|(=
?!))</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        PCRE, Perl, Python</p>
<pre>\b(?:(?:(one)|(two)|(three))(?:,|\b)){3,}</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>2.18. Add Comments to a Regular Expression</h2>
<h3>Solution</h3>
<pre>\d{4}    # Year
-        # Separator
\d{2}    # Month
-        # Separator
\d{2}    # Day</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>(?#Year)\d{4}(?#Separator)-(?#Month)\d{2}-(?#Day)\d{2}</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>(?x)\d{4}    # Year
-            # Separator
\d{2}        # Month
-            # Separator
\d{2}        # Day</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>2.19. Insert Literal Text into the Replacement Text</h2>
<h3>Solution</h3>
<pre>$%\*$$1\1</pre>
<pre>\$%\\*\$1\\1</pre>
<pre>$%\*\$1\\1</pre>
<pre>\$%\*\$1\\1</pre>
<pre>$%\*$1\\1</pre>
<h3>Discussion</h3>
<h4>.NET and JavaScript</h4>
<pre>$$%\*$$1\1</pre>
<h2>2.20. Insert the Regex Match into the Replacement Text</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>http:\S+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>&lt;a href=3D"$&amp;"&gt;$&amp;&lt;/a&gt;</pre>
<pre>&lt;a href=3D"$0"&gt;$0&lt;/a&gt;</pre>
<pre>&lt;a href=3D"\0"&gt;\0&lt;/a&gt;</pre>
<pre>&lt;a href=3D"\&amp;"&gt;\&amp;&lt;/a&gt;</pre>
<pre>&lt;a href=3D"\g&lt;0&gt;"&gt;\g&lt;0&gt;&lt;/a&gt;</pre>
<h2>2.21. Insert Part of the Regex Match into the Replacement Text</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>\b(\d{3})(\d{3})(\d{4})\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>($1) $2-$3</pre>
<pre>(${1}) ${2}-${3}</pre>
<pre>(\1) \2-\3</pre>
<h3>Solution Using Named Capture</h3>
<h4>Regular expression</h4>
<pre>\b(?&lt;area&gt;\d{3})(?&lt;exchange&gt;\d{3})(?&lt;number&gt;\d{4})\b=
</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b(?'area'\d{3})(?'exchange'\d{3})(?'number'\d{4})\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b(?P&lt;area&gt;\d{3})(?P&lt;exchange&gt;\d{3})(?P&lt;number&gt;\d{4}=
)\b</pre>
<p>Regex options: None<br>
Regex flavors: PCRE,
          Perl 5.10, Python</p>
<h4>Replacement</h4>
<pre>(${area}) ${exchange}-${number}</pre>
<pre>(\g&lt;area&gt;) \g&lt;exchange&gt;-\g&lt;number&gt;</pre>
<pre>(\k&lt;area&gt;) \k&lt;exchange&gt;-\k&lt;number&gt;</pre>
<pre>(\k'area') \k'exchange'-\k'number'</pre>
<pre>($+{area}) $+{exchange}-$+{number}</pre>
<pre>($1) $2-$3</pre>
<h2>2.22. Insert Match Context into the Replacement Text</h2>
<h3>Solution</h3>
<pre>$`$_$'</pre>
<pre>\`\`\&amp;\'\'</pre>
<pre>$`$`$&amp;$'$'</pre>
<h1>3. Programming with Regular Expressions</h1>
<h2>3.1. Literal Regular Expressions in Source Code</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>"[$\"'\n\\d/\\\\]"</pre>
<pre>@"[$""'\n\d/\\]"</pre>
<h4>VB.NET</h4>
<pre>"[$""'\n\d/\\]"</pre>
<h4>Java</h4>
<pre>"[$\"'\n\\d/\\\\]"</pre>
<h4>JavaScript</h4>
<pre>/[$"'\n\d\/\\]/</pre>
<h4>XRegExp</h4>
<pre>"[$\"'\n\\d/\\\\]"</pre>
<h4>PHP</h4>
<pre>'%[$"\'\n\d/\\\\]%'</pre>
<h4>Perl</h4>
<pre>/[\$"'\n\d\/\\]/</pre>
<pre>m![\$"'\n\d/\\]!</pre>
<pre>s![\$"'\n\d/\\]!!</pre>
<h4>Python</h4>
<pre>r"""[$"'\n\d/\\]"""</pre>
<pre>"[$\"'\n\\d/\\\\]"</pre>
<h4>Ruby</h4>
<pre>/[$"'\n\d\/\\]/</pre>
<pre>%r![$"'\n\d/\\]!</pre>
<h2>3.2. Import the Regular Expression Library</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>using System.Text.RegularExpressions;</pre>
<h4>VB.NET</h4>
<pre>Imports System.Text.RegularExpressions</pre>
<h4>XRegExp</h4>
<pre>&lt;script src=3D"xregexp-all-min.js"&gt;&lt;/script&gt;</pre>
<pre>var XRegExp =3D require('xregexp').XRegExp;</pre>
<h4>Java</h4>
<pre>import java.util.regex.*;</pre>
<h4>Python</h4>
<pre>import re</pre>
<h2>3.3. Create Regular Expression Objects</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>Regex regexObj =3D new Regex("<i>regex pattern</i>");</pre>
<pre>try {
    Regex regexObj =3D new Regex(UserInput);
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>VB.NET</h4>
<pre>Dim RegexObj As New Regex("<i>regex pattern</i>")</pre>
<pre>Try
    Dim RegexObj As New Regex(UserInput)
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<h4>Java</h4>
<pre>Pattern regex =3D Pattern.compile("<i>regex pattern</i>");</pre>
<pre>try {
	Pattern regex =3D Pattern.compile(userInput);
} catch (PatternSyntaxException ex) {
	// Syntax error in the regular expression
}</pre>
<pre>Matcher regexMatcher =3D regex.matcher(subjectString);</pre>
<pre>regexMatcher.reset(anotherSubjectString);</pre>
<h4>JavaScript</h4>
<pre>var myregexp =3D /<i>regex pattern</i>/;</pre>
<pre>var myregexp =3D new RegExp(userinput);</pre>
<h4>XRegExp</h4>
<pre>var myregexp =3D XRegExp("<i>regex pattern</i>");</pre>
<h4>Perl</h4>
<pre>$myregex =3D qr/<i>regex pattern</i>/</pre>
<pre>$myregex =3D qr/$userinput/</pre>
<h4>Python</h4>
<pre>reobj =3D re.compile("<i>regex pattern</i>")</pre>
<pre>reobj =3D re.compile(userinput)</pre>
<h4>Ruby</h4>
<pre>myregexp =3D /<i>regex pattern</i>/;</pre>
<pre>myregexp =3D Regexp.new(userinput);</pre>
<h3>Compiling a Regular Expression Down to CIL</h3>
<h4>C#</h4>
<pre>Regex regexObj =3D new Regex("<i>regex pattern</i>", RegexOptions.Comp=
iled);</pre>
<h4>VB.NET</h4>
<pre>Dim RegexObj As New Regex("<i>regex pattern</i>", RegexOptions.Compile=
d)</pre>
<h2>3.4. Set Regular Expression Options</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>Regex regexObj =3D new Regex("<i>regex pattern</i>",
    RegexOptions.IgnorePatternWhitespace | RegexOptions.IgnoreCase |
    RegexOptions.Singleline | RegexOptions.Multiline);</pre>
<h4>VB.NET</h4>
<pre>Dim RegexObj As New Regex("<i>regex pattern</i>",
    RegexOptions.IgnorePatternWhitespace Or RegexOptions.IgnoreCase Or
    RegexOptions.Singleline Or RegexOptions.Multiline)</pre>
<h4>Java</h4>
<pre>Pattern regex =3D Pattern.compile("<i>regex pattern</i>",
    Pattern.COMMENTS | Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE |
    Pattern.DOTALL | Pattern.MULTILINE);</pre>
<h4>JavaScript</h4>
<pre>var myregexp =3D /<i>regex pattern</i>/im;</pre>
<pre>var myregexp =3D new RegExp(userinput, "im");</pre>
<h4>XRegExp</h4>
<pre>var myregexp =3D XRegExp("<i>regex pattern</i>", "xism");</pre>
<h4>PHP</h4>
<pre>regexstring =3D '/<i>regex pattern</i>/xism';</pre>
<h4>Perl</h4>
<pre>m/<i>regex pattern</i>/xism;</pre>
<h4>Python</h4>
<pre>reobj =3D re.compile("<i>regex pattern</i>",
    re.VERBOSE | re.IGNORECASE |
    re.DOTALL | re.MULTILINE)</pre>
<h4>Ruby</h4>
<pre>myregexp =3D /<i>regex pattern</i>/xim;</pre>
<pre>myregexp =3D Regexp.new(userinput,
    Regexp::EXTENDED or Regexp::IGNORECASE or
    Regexp::MULTILINE);</pre>
<h2>3.5. Test If a Match Can Be Found Within a Subject String</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>bool foundMatch =3D Regex.IsMatch(subjectString, "<i>regex pattern</i>=
");</pre>
<pre>bool foundMatch =3D false;
try {
    foundMatch =3D Regex.IsMatch(subjectString, UserInput);
} catch (ArgumentNullException ex) {
    // Cannot pass null as the regular expression or subject string
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<pre>Regex regexObj =3D new Regex("<i>regex pattern</i>");
bool foundMatch =3D regexObj.IsMatch(subjectString);</pre>
<pre>bool foundMatch =3D false;
try {
    Regex regexObj =3D new Regex(UserInput);
    try {
        foundMatch =3D regexObj.IsMatch(subjectString);
    } catch (ArgumentNullException ex) {
        // Cannot pass null as the regular expression or subject string
    }
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>VB.NET</h4>
<pre>Dim FoundMatch =3D Regex.IsMatch(SubjectString, "<i>regex pattern</i>"=
)</pre>
<pre>Dim FoundMatch As Boolean
Try
    FoundMatch =3D Regex.IsMatch(SubjectString, UserInput)
Catch ex As ArgumentNullException
    'Cannot pass Nothing as the regular expression or subject string
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<pre>Dim RegexObj As New Regex("<i>regex pattern</i>")
Dim FoundMatch =3D RegexObj.IsMatch(SubjectString)</pre>
<pre>Dim FoundMatch =3D RegexObj.IsMatch(SubjectString)</pre>
<pre>Dim FoundMatch As Boolean
Try
    Dim RegexObj As New Regex(UserInput)
    Try
        FoundMatch =3D Regex.IsMatch(SubjectString)
    Catch ex As ArgumentNullException
        'Cannot pass Nothing as the regular expression or subject string
    End Try
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<h4>Java</h4>
<pre>Pattern regex =3D Pattern.compile("<i>regex pattern</i>");
Matcher regexMatcher =3D regex.matcher(subjectString);
boolean foundMatch =3D regexMatcher.find();</pre>
<pre>boolean foundMatch =3D false;
try {
	Pattern regex =3D Pattern.compile(UserInput);
	Matcher regexMatcher =3D regex.matcher(subjectString);
	foundMatch =3D regexMatcher.find();
} catch (PatternSyntaxException ex) {
	// Syntax error in the regular expression
}</pre>
<h4>JavaScript</h4>
<pre>if (/regex pattern/.test(subject)) {
    // Successful match
} else {
    // Match attempt failed
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('/regex pattern/', $subject)) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<h4>Perl</h4>
<pre>if (m/regex pattern/) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<pre>if ($subject =3D~ m/regex pattern/) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<pre>$regex =3D qr/regex pattern/;
if ($subject =3D~ $regex) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<h4>Python</h4>
<pre>if re.search("regex pattern", subject):
    # Successful match
else:
    # Match attempt failed</pre>
<pre>reobj =3D re.compile("regex pattern")
if reobj.search(subject):
    # Successful match
else:
    # Match attempt failed</pre>
<h4>Ruby</h4>
<pre>if subject =3D~ /regex pattern/
    # Successful match
else
    # Match attempt failed
end</pre>
<pre>if /regex pattern/ =3D~ subject
    # Successful match
else
    # Match attempt failed
end</pre>
<h2>3.6. Test Whether a Regex Matches the Subject String Entirely</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>bool foundMatch =3D Regex.IsMatch(subjectString, @"\A<i>regex pattern<=
/i>\Z");</pre>
<pre>Regex regexObj =3D new Regex(@"\A<i>regex pattern</i>\Z");
bool foundMatch =3D regexObj.IsMatch(subjectString);</pre>
<h4>VB.NET</h4>
<pre>Dim FoundMatch =3D Regex.IsMatch(SubjectString, "\A<i>regex pattern</i=
>\Z")</pre>
<pre>Dim RegexObj As New Regex("\A<i>regex pattern</i>\Z")
Dim FoundMatch =3D RegexObj.IsMatch(SubjectString)</pre>
<pre>Dim FoundMatch =3D RegexObj.IsMatch(SubjectString)</pre>
<h4>Java</h4>
<pre>boolean foundMatch =3D subjectString.matches("<i>regex pattern</i>");<=
/pre>
<pre>Pattern regex =3D Pattern.compile("<i>regex pattern</i>");
Matcher regexMatcher =3D regex.matcher(subjectString);
boolean foundMatch =3D regexMatcher.matches(subjectString);</pre>
<h4>JavaScript</h4>
<pre>if (/^<i>regex pattern</i>$/.test(subject)) {
    // Successful match
} else {
    // Match attempt failed
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('/\A<i>regex pattern</i>\Z/', $subject)) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<h4>Perl</h4>
<pre>if ($subject =3D~ m/\A<i>regex pattern</i>\Z/) {
    # Successful match
} else {
    # Match attempt failed
}</pre>
<h4>Python</h4>
<pre>if re.match(r"<i>regex pattern</i>\Z", subject):
    # Successful match
else:
    # Match attempt failed</pre>
<pre>reobj =3D re.compile(r"<i>regex pattern</i>\Z")
if reobj.match(subject):
    # Successful match
else:
    # Match attempt failed</pre>
<h4>Ruby</h4>
<pre>if subject =3D~ /\A<i>regex pattern</i>\Z/
    # Successful match
else
    # Match attempt failed
end</pre>
<h2>3.7. Retrieve the Matched Text</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString =3D Regex.Match(subjectString, @"\d+").Value;</pre=
>
<pre>string resultString =3D null;
try {
    resultString =3D Regex.Match(subjectString, @"\d+").Value;
} catch (ArgumentNullException ex) {
    // Cannot pass null as the regular expression or subject string
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<pre>Regex regexObj =3D new Regex(@"\d+");
string resultString =3D regexObj.Match(subjectString).Value;</pre>
<pre>string resultString =3D null;
try {
    Regex regexObj =3D new Regex(@"\d+");
    try {
        resultString =3D regexObj.Match(subjectString).Value;
    } catch (ArgumentNullException ex) {
        // Cannot pass null as the subject string
    }
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString  =3D Regex.Match(SubjectString, "\d+").Value</pre>
<pre>Dim ResultString As String =3D Nothing
Try
    ResultString =3D Regex.Match(SubjectString, "\d+").Value
Catch ex As ArgumentNullException
    'Cannot pass Nothing as the regular expression or subject string
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<pre>Dim RegexObj As New Regex("\d+")
Dim ResultString =3D RegexObj.Match(SubjectString).Value</pre>
<pre>Dim ResultString As String =3D Nothing
Try
    Dim RegexObj As New Regex("\d+")
    Try
        ResultString =3D RegexObj.Match(SubjectString).Value
    Catch ex As ArgumentNullException
        'Cannot pass Nothing as the subject string
    End Try
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<h4>Java</h4>
<pre>String resultString =3D null;
Pattern regex =3D Pattern.compile("\\d+");
Matcher regexMatcher =3D regex.matcher(subjectString);
if (regexMatcher.find()) {
    resultString =3D regexMatcher.group();
}</pre>
<pre>String resultString =3D null;
try {
    Pattern regex =3D Pattern.compile("\\d+");
    Matcher regexMatcher =3D regex.matcher(subjectString);
    if (regexMatcher.find()) {
        resultString =3D regexMatcher.group();
    }
} catch (PatternSyntaxException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>JavaScript</h4>
<pre>var result =3D subject.match(/\d+/);
if (result) {
    result =3D result[0];
} else {
    result =3D '';
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('/\d+/', $subject, $groups)) {
    $result =3D $groups[0];
} else {
    $result =3D '';
}</pre>
<h4>Perl</h4>
<pre>if ($subject =3D~ m/\d+/) {
    $result =3D $&amp;;
} else {
    $result =3D '';
}</pre>
<h4>Python</h4>
<pre>matchobj =3D re.search("regex pattern", subject)
if matchobj:
    result =3D matchobj.group()
else:
    result =3D ""</pre>
<pre>reobj =3D re.compile("regex pattern")
matchobj =3D reobj.search(subject)
if match:
    result =3D matchobj.group()
else:
    result =3D ""</pre>
<h4>Ruby</h4>
<pre>if subject =3D~ /regex pattern/
    result =3D $&amp;
else
    result =3D ""
end</pre>
<pre>matchobj =3D /regex pattern/.match(subject)
if matchobj
    result =3D matchobj[0]
else
    result =3D ""
end</pre>
<h2>3.8. Determine the Position and Length of the Match</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>int matchstart, matchlength =3D -1;
Match matchResult =3D Regex.Match(subjectString, @"\d+");
if (matchResult.Success) {
    matchstart =3D matchResult.Index;
    matchlength =3D matchResult.Length;
}</pre>
<pre>int matchstart, matchlength =3D -1;
Regex regexObj =3D new Regex(@"\d+");
Match matchResult =3D regexObj.Match(subjectString).Value;
if (matchResult.Success) {
    matchstart =3D matchResult.Index;
    matchlength =3D matchResult.Length;
}</pre>
<h4>VB.NET</h4>
<pre>Dim MatchStart =3D -1
Dim MatchLength =3D -1
Dim MatchResult =3D Regex.Match(SubjectString, "\d+")
If MatchResult.Success Then
    MatchStart =3D MatchResult.Index
    MatchLength =3D MatchResult.Length
End If</pre>
<pre>Dim MatchStart =3D -1
Dim MatchLength =3D -1
Dim RegexObj As New Regex("\d+")
Dim MatchResult =3D Regex.Match(SubjectString, "\d+")
If MatchResult.Success Then
    MatchStart =3D MatchResult.Index
    MatchLength =3D MatchResult.Length
End If</pre>
<h4>Java</h4>
<pre>int matchStart, matchLength =3D -1;
Pattern regex =3D Pattern.compile("\\d+");
Matcher regexMatcher =3D regex.matcher(subjectString);
if (regexMatcher.find()) {
	matchStart =3D regexMatcher.start();
	matchLength =3D regexMatcher.end() - matchStart;
}</pre>
<h4>JavaScript</h4>
<pre>var matchstart =3D -1;
var matchlength =3D -1;
var match =3D /\d+/.exec(subject);
if (match) {
    matchstart =3D match.index;
    matchlength =3D match[0].length;
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('/\d+/', $subject, $groups, PREG_OFFSET_CAPTURE)) {
    $matchstart =3D $groups[0][1];
    $matchlength =3D strlen($groups[0][0]);
}</pre>
<h4>Perl</h4>
<pre>if ($subject =3D~ m/\d+/g) {
    $matchstart =3D $-[0];
    $matchlength =3D $+[0] - $-[0];
}</pre>
<h4>Python</h4>
<pre>matchobj =3D re.search(r"\d+", subject)
if matchobj:
    matchstart =3D matchobj.start()
    matchlength =3D matchobj.end() - matchstart</pre>
<pre>reobj =3D re.compile(r"\d+")
matchobj =3D reobj.search(subject)
if matchobj:
    matchstart =3D matchobj.start()
    matchlength =3D matchobj.end() - matchstart</pre>
<h4>Ruby</h4>
<pre>if subject =3D~ /regex pattern/
    matchstart =3D $~.begin()
    matchlength =3D $~.end() - matchstart
end</pre>
<pre>matchobj =3D /regex pattern/.match(subject)
if matchobj
    matchstart =3D matchobj.begin()
    matchlength =3D matchobj.end() - matchstart
end</pre>
<h2>3.9. Retrieve Part of the Matched Text</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString =3D Regex.Match(subjectString,
                      "http://([a-z0-9.-]+)").Groups[1].Value;</pre>
<pre>Regex regexObj =3D new Regex("http://([a-z0-9.-]+)");
string resultString =3D regexObj.Match(subjectString).Groups[1].Value;</pre=
>
<h4>VB.NET</h4>
<pre>Dim ResultString =3D Regex.Match(SubjectString,
                   "http://([a-z0-9.-]+)").Groups(1).Value</pre>
<pre>Dim RegexObj As New Regex("http://([a-z0-9.-]+)")
Dim ResultString =3D RegexObj.Match(SubjectString).Groups(1).Value</pre>
<h4>Java</h4>
<pre>String resultString =3D null;
Pattern regex =3D Pattern.compile("http://([a-z0-9.-]+)");
Matcher regexMatcher =3D regex.matcher(subjectString);
if (regexMatcher.find()) {
    resultString =3D regexMatcher.group(1);
}</pre>
<h4>JavaScript</h4>
<pre>var result;
var match =3D /http:\/\/([a-z0-9.-]+)/.exec(subject);
if (match) {
    result =3D match[1];
} else {
    result =3D "";
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('%http://([a-z0-9.-]+)%', $subject, $groups)) {
    $result =3D $groups[1];
} else {
    $result =3D '';
}</pre>
<h4>Perl</h4>
<pre>if ($subject =3D~ m!http://([a-z0-9.-]+)!) {
    $result =3D $1;
} else {
    $result =3D '';
}</pre>
<h4>Python</h4>
<pre>matchobj =3D re.search("http://([a-z0-9.-]+)", subject)
if matchobj:
    result =3D matchobj.group(1)
else:
    result =3D ""</pre>
<pre>reobj =3D re.compile("http://([a-z0-9.-]+)")
matchobj =3D reobj.search(subject)
if match:
    result =3D matchobj.group(1)
else:
    result =3D ""</pre>
<h4>Ruby</h4>
<pre>if subject =3D~ %r!http://([a-z0-9.-]+)!
    result =3D $1
else
    result =3D ""
end</pre>
<pre>matchobj =3D %r!http://([a-z0-9.-]+)!.match(subject)
if matchobj
    result =3D matchobj[1]
else
    result =3D ""
end</pre>
<h3>Named Capture</h3>
<h4>C#</h4>
<pre>string resultString =3D Regex.Match(subjectString,
               "http://(?&lt;domain&gt;[a-z0-9.-]+)").Groups["domain"].Valu=
e;</pre>
<pre>Regex regexObj =3D new Regex("http://(?&lt;domain&gt;[a-z0-9.-]+)");
string resultString =3D regexObj.Match(subjectString).Groups["domain"].Valu=
e;</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString =3D Regex.Match(SubjectString,
                   "http://(?&lt;domain&gt;[a-z0-9.-]+)").Groups("domain").=
Value</pre>
<pre>Dim RegexObj As New Regex("http://(?&lt;domain&gt;[a-z0-9.-]+)")
Dim ResultString =3D RegexObj.Match(SubjectString).Groups("domain").Value</=
pre>
<h4>Java</h4>
<pre>String resultString =3D null;
Pattern regex =3D Pattern.compile("http://(?&lt;domain&gt;[a-z0-9.-]+)");
Matcher regexMatcher =3D regex.matcher(subjectString);
if (regexMatcher.find()) {
    resultString =3D regexMatcher.group("domain");
}</pre>
<h4>XRegExp</h4>
<pre>var result;
var match =3D XRegExp.exec(subject,=20
                         XRegExp("http://(?&lt;domain&gt;[a-z0-9.-]+)"));
if (match) {
    result =3D match.domain;
} else {
    result =3D "";
}</pre>
<h4>PHP</h4>
<pre>if (preg_match('%http://(?P&lt;domain&gt;[a-z0-9.-]+)%', $subject, $gr=
oups)) {
    $result =3D $groups['domain'];
} else {
    $result =3D '';
}</pre>
<h4>Perl</h4>
<pre>if ($subject =3D~ '!http://(?&lt;domain&gt;[a-z0-9.-]+)%!) {
    $result =3D $+{'domain'};
} else {
    $result =3D '';
}</pre>
<h4>Python</h4>
<pre>matchobj =3D re.search("http://(?P&lt;domain&gt;[a-z0-9.-]+)", subject=
)
if matchobj:
    result =3D matchobj.group("domain")
else:
    result =3D ""</pre>
<h2>3.10. Retrieve a List of All Matches</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>MatchCollection matchlist =3D Regex.Matches(subjectString, @"\d+");</p=
re>
<pre>Regex regexObj =3D new Regex(@"\d+");
MatchCollection matchlist =3D regexObj.Matches(subjectString);</pre>
<h4>VB.NET</h4>
<pre>Dim MatchList =3D Regex.Matches(SubjectString, "\d+")</pre>
<pre>Dim RegexObj As New Regex("\d+")
Dim MatchList =3D RegexObj.Matches(SubjectString)</pre>
<h4>Java</h4>
<pre>List&lt;String&gt; resultList =3D new ArrayList&lt;String&gt;();
Pattern regex =3D Pattern.compile("\\d+");
Matcher regexMatcher =3D regex.matcher(subjectString);
while (regexMatcher.find()) {
    resultList.add(regexMatcher.group());
}</pre>
<h4>JavaScript</h4>
<pre>var list =3D subject.match(/\d+/g);</pre>
<h4>PHP</h4>
<pre>preg_match_all('/\d+/', $subject, $result, PREG_PATTERN_ORDER);
$result =3D $result[0];</pre>
<h4>Perl</h4>
<pre>@result =3D $subject =3D~ m/\d+/g;</pre>
<h4>Python</h4>
<pre>result =3D re.findall(r"\d+", subject)</pre>
<pre>reobj =3D re.compile(r"\d+")
result =3D reobj.findall(subject)</pre>
<h4>Ruby</h4>
<pre>result =3D subject.scan(/\d+/)</pre>
<h2>3.11. Iterate over All Matches</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>Match matchResult =3D Regex.Match(subjectString, @"\d+");
while (matchResult.Success) {
    // Here you can process the match stored in matchResult
    matchResult =3D matchResult.NextMatch();
}</pre>
<pre>Regex regexObj =3D new Regex(@"\d+");
matchResult =3D regexObj.Match(subjectString);
while (matchResult.Success) {
    // Here you can process the match stored in matchResult
    matchResult =3D matchResult.NextMatch();
}</pre>
<h4>VB.NET</h4>
<pre>Dim MatchResult =3D Regex.Match(SubjectString, "\d+")
While MatchResult.Success
    'Here you can process the match stored in MatchResult
    MatchResult =3D MatchResult.NextMatch
End While</pre>
<pre>Dim RegexObj As New Regex("\d+")
Dim MatchResult =3D RegexObj.Match(SubjectString)
While MatchResult.Success
    'Here you can process the match stored in MatchResult
    MatchResult =3D MatchResult.NextMatch
End While</pre>
<h4>Java</h4>
<pre>Pattern regex =3D Pattern.compile("\\d+");
Matcher regexMatcher =3D regex.matcher(subjectString);
while (regexMatcher.find()) {
    // Here you can process the match stored in regexMatcher
}</pre>
<h4>JavaScript</h4>
<pre>var regex =3D /\d+/g;
var match =3D null;
while (match =3D regex.exec(subject)) {
  // Don't let browsers get stuck in an infinite loop
  if (match.index =3D=3D regex.lastIndex) regex.lastIndex++;
  // Here you can process the match stored in the match variable
}</pre>
<pre>var regex =3D /\d+/g;
var match =3D null;
while (match =3D regex.exec(subject)) {
  // Here you can process the match stored in the match variable
}</pre>
<h4>XRegExp</h4>
<pre>XRegExp.forEach(subject, /\d+/, function(match) {
  // Here you can process the match stored in the match variable
});</pre>
<h4>PHP</h4>
<pre>preg_match_all('/\d+/', $subject, $result, PREG_PATTERN_ORDER);
for ($i =3D 0; $i &lt; count($result[0]); $i++) {
    # Matched text =3D $result[0][$i];
}</pre>
<h4>Perl</h4>
<pre>while ($subject =3D~ m/\d+/g) {
    # matched text =3D $&amp;
}</pre>
<h4>Python</h4>
<pre>for matchobj in re.finditer(r"\d+", subject):
    # Here you can process the match stored in the matchobj variable</pre>
<pre>reobj =3D re.compile(r"\d+")
for matchobj in reobj.finditer(subject):
    # Here you can process the match stored in the matchobj variable</pre>
<h4>Ruby</h4>
<pre>subject.scan(/\d+/) {|match|
    # Here you can process the match stored in the match variable
}</pre>
<h3>Discussion</h3>
<h4>Ruby</h4>
<pre>subject.scan(/(a)(b)(c)/) {|a, b, c|
    # a, b, and c hold the text matched by the three capturing groups
}</pre>
<pre>subject.scan(/(a)(b)(c)/) {|abc|
    # abc[0], abc[1], and abc[2] hold the text
    # matched by the three capturing groups
}</pre>
<h2>3.12. Validate Matches in Procedural Code</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>StringCollection resultList =3D new StringCollection();
Match matchResult =3D Regex.Match(subjectString, @"\d+");
while (matchResult.Success) {
    if (int.Parse(matchResult.Value) % 13 =3D=3D 0) {
        resultList.Add(matchResult.Value);
    }
    matchResult =3D matchResult.NextMatch();
}</pre>
<pre>StringCollection resultList =3D new StringCollection();
Regex regexObj =3D new Regex(@"\d+");
matchResult =3D regexObj.Match(subjectString);
while (matchResult.Success) {
    if (int.Parse(matchResult.Value) % 13 =3D=3D 0) {
        resultList.Add(matchResult.Value);
    }
    matchResult =3D matchResult.NextMatch();
}</pre>
<h4>VB.NET</h4>
<pre>Dim ResultList =3D New StringCollection
Dim MatchResult =3D Regex.Match(SubjectString, "\d+")
While MatchResult.Success
    If Integer.Parse(MatchResult.Value) Mod 13 =3D 0 Then
        ResultList.Add(MatchResult.Value)
    End If
    MatchResult =3D MatchResult.NextMatch
End While</pre>
<pre>Dim ResultList =3D New StringCollection
Dim RegexObj As New Regex("\d+")
Dim MatchResult =3D RegexObj.Match(SubjectString)
While MatchResult.Success
    If Integer.Parse(MatchResult.Value) Mod 13 =3D 0 Then
        ResultList.Add(MatchResult.Value)
    End If
    MatchResult =3D MatchResult.NextMatch
End While</pre>
<h4>Java</h4>
<pre>List&lt;String&gt; resultList =3D new ArrayList&lt;String&gt;();
Pattern regex =3D Pattern.compile("\\d+");
Matcher regexMatcher =3D regex.matcher(subjectString);
while (regexMatcher.find()) {
    if (Integer.parseInt(regexMatcher.group()) % 13 =3D=3D 0) {
        resultList.add(regexMatcher.group());
    }
}</pre>
<h4>JavaScript</h4>
<pre>var list =3D [];
var regex =3D /\d+/g;
var match =3D null;
while (match =3D regex.exec(subject)) {
    // Don't let browsers get stuck in an infinite loop
    if (match.index =3D=3D regex.lastIndex) regex.lastIndex++;
    // Here you can process the match stored in the match variable
    if (match[0] % 13 =3D=3D 0) {
        list.push(match[0]);
    }
}</pre>
<h4>XRegExp</h4>
<pre>var list =3D [];
XRegExp.forEach(subject, /\d+/, function(match) {
   if (match[0] % 13 =3D=3D 0) {
       list.push(match[0]);
   }
});</pre>
<h4>PHP</h4>
<pre>preg_match_all('/\d+/', $subject, $matchdata, PREG_PATTERN_ORDER);
for ($i =3D 0; $i &lt; count($matchdata[0]); $i++) {
    if ($matchdata[0][$i] % 13 =3D=3D 0) {
      $list[] =3D $matchdata[0][$i];
    }
}</pre>
<h4>Perl</h4>
<pre>while ($subject =3D~ m/\d+/g) {
    if ($&amp; % 13 =3D=3D 0) {
        push(@list, $&amp;);
    }
}</pre>
<h4>Python</h4>
<pre>list =3D []
for matchobj in re.finditer(r"\d+", subject):
    if int(matchobj.group()) % 13 =3D=3D 0:
       list.append(matchobj.group())</pre>
<pre>list =3D []
reobj =3D re.compile(r"\d+")
for matchobj in reobj.finditer(subject):
    if int(matchobj.group()) % 13 =3D=3D 0:
       list.append(matchobj.group())</pre>
<h4>Ruby</h4>
<pre>list =3D []
subject.scan(/\d+/) {|match|
    list &lt;&lt; match if (Integer(match) % 13 =3D=3D 0)
}</pre>
<h2>3.13. Find a Match Within Another Match</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>StringCollection resultList =3D new StringCollection();
Regex outerRegex =3D new Regex("&lt;b&gt;(.*?)&lt;/b&gt;", RegexOptions.Sin=
gleline);
Regex innerRegex =3D new Regex(@"\d+");
// Find the first section
Match outerMatch =3D outerRegex.Match(subjectString);
while (outerMatch.Success) {
    // Get the matches within the section
	Match innerMatch =3D innerRegex.Match(outerMatch.Groups[1].Value);
	while (innerMatch.Success) {
		resultList.Add(innerMatch.Value);
		innerMatch =3D innerMatch.NextMatch();
	}
	// Find the next section
    outerMatch =3D outerMatch.NextMatch();
}</pre>
<h4>VB.NET</h4>
<pre>Dim ResultList =3D New StringCollection
Dim OuterRegex As New Regex("&lt;b&gt;(.*?)&lt;/b&gt;", RegexOptions.Single=
line)
Dim InnerRegex As New Regex("\d+")
'Find the first section
Dim OuterMatch =3D OuterRegex.Match(SubjectString)
While OuterMatch.Success
    'Get the matches within the section
    Dim InnerMatch =3D InnerRegex.Match(OuterMatch.Groups(1).Value)
    While InnerMatch.Success
        ResultList.Add(InnerMatch.Value)
        InnerMatch =3D InnerMatch.NextMatch
    End While
    OuterMatch =3D OuterMatch.NextMatch
End While</pre>
<h4>Java</h4>
<pre>List&lt;String&gt; resultList =3D new ArrayList&lt;String&gt;();
Pattern outerRegex =3D Pattern.compile("&lt;b&gt;(.*?)&lt;/b&gt;", Pattern.=
DOTALL);
Pattern innerRegex =3D Pattern.compile("\\d+");
Matcher outerMatcher =3D outerRegex.matcher(subjectString);
while (outerMatcher.find()) {
    Matcher innerMatcher =3D innerRegex.matcher(outerMatcher.group(1));
    while (innerMatcher.find()) {
        resultList.add(innerMatcher.group());
    }
}</pre>
<pre>List&lt;String&gt; resultList =3D new ArrayList&lt;String&gt;();
Pattern outerRegex =3D Pattern.compile("&lt;b&gt;(.*?)&lt;/b&gt;", Pattern.=
DOTALL);
Pattern innerRegex =3D Pattern.compile("\\d+");
Matcher outerMatcher =3D outerRegex.matcher(subjectString);
Matcher innerMatcher =3D innerRegex.matcher(subjectString);
while (outerMatcher.find()) {
    innerMatcher.region(outerMatcher.start(1), outerMatcher.end(1));
    while (innerMatcher.find()) {
        resultList.add(innerMatcher.group());
    }
}</pre>
<h4>JavaScript</h4>
<pre>var result =3D [];
var outerRegex =3D /&lt;b&gt;([\s\S]*?)&lt;\/b&gt;/g;
var innerRegex =3D /\d+/g;
var outerMatch;
var innerMatches;
while (outerMatch =3D outerRegex.exec(subject)) {
    if (outerMatch.index =3D=3D outerRegex.lastIndex)
        outerRegex.lastIndex++;
    innerMatches =3D outerMatch[1].match(innerRegex);
    if (innerMatches) {
        result =3D result.concat(innerMatches);
    }
}</pre>
<h4>XRegExp</h4>
<pre>var result =3D XRegExp.matchChain(subject, [
    {regex: XRegExp("&lt;b&gt;(.*?)&lt;/b&gt;", "s"), backref: 1},
    /\d+/
]);</pre>
<pre>var result =3D [];
var outerRegex =3D XRegExp("&lt;b&gt;(.*?)&lt;/b&gt;", "s");
var innerRegex =3D /\d+/g;
XRegExp.forEach(subject, outerRegex, function(outerMatch) {
    var innerMatches =3D outerMatch[1].match(innerRegex);
    if (innerMatches) {
        result =3D result.concat(innerMatches);
    }
});</pre>
<h4>PHP</h4>
<pre>$list =3D array();
preg_match_all('%&lt;b&gt;(.*?)&lt;/b&gt;%s', $subject, $outermatches,
               PREG_PATTERN_ORDER);
for ($i =3D 0; $i &lt; count($outermatches[0]); $i++) {
    if (preg_match_all('/\d+/', $outermatches[1][$i], $innermatches,
                       PREG_PATTERN_ORDER)) {
        $list =3D array_merge($list, $innermatches[0]);
    }
}</pre>
<h4>Perl</h4>
<pre>while ($subject =3D~ m!&lt;b&gt;(.*?)&lt;/b&gt;!gs) {
    push(@list, ($1 =3D~ m/\d+/g));
}</pre>
<h4>Python</h4>
<pre>list =3D []
innerre =3D re.compile(r"\d+")
for outermatch in re.finditer("(?s)&lt;b&gt;(.*?)&lt;/b&gt;", subject):
    list.extend(innerre.findall(outermatch.group(1)))</pre>
<h4>Ruby</h4>
<pre>list =3D []
subject.scan(/&lt;b&gt;(.*?)&lt;\/b&gt;/m) {|outergroups|
    list +=3D outergroups[1].scan(/\d+/)
}</pre>
<h3>Discussion</h3>
<pre>\d+(?=3D(?:(?!&lt;b&gt;).)*&lt;/b&gt;)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>3.14. Replace All Matches</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString =3D Regex.Replace(subjectString, "before", "after"=
);</pre>
<pre>string resultString =3D null;
try {
    resultString =3D Regex.Replace(subjectString, "before", "after");
} catch (ArgumentNullException ex) {
    // Cannot pass null as the regular expression, subject string,
    // or replacement text
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<pre>Regex regexObj =3D new Regex("before");
string resultString =3D regexObj.Replace(subjectString, "after");</pre>
<pre>string resultString =3D null;
try {
    Regex regexObj =3D new Regex("before");
    try {
        resultString =3D regexObj.Replace(subjectString, "after");
    } catch (ArgumentNullException ex) {
        // Cannot pass null as the subject string or replacement text
    }
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString =3D Regex.Replace(SubjectString, "before", "after")</=
pre>
<pre>Dim ResultString As String =3D Nothing
Try
    ResultString =3D Regex.Replace(SubjectString, "before", "after")
Catch ex As ArgumentNullException
    'Cannot pass null as the regular expression, subject string,
    'or replacement text
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<pre>Dim RegexObj As New Regex("before")
Dim ResultString =3D RegexObj.Replace(SubjectString, "after")</pre>
<pre>Dim ResultString As String =3D Nothing
Try
    Dim RegexObj As New Regex("before")
    Try
        ResultString =3D RegexObj.Replace(SubjectString, "after")
    Catch ex As ArgumentNullException
       'Cannot pass null as the subject string or replacement text
    End Try
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<h4>Java</h4>
<pre>String resultString =3D subjectString.replaceAll("before", "after");</=
pre>
<pre>try {
    String resultString =3D subjectString.replaceAll("before", "after");
} catch (PatternSyntaxException ex) {
    // Syntax error in the regular expression
} catch (IllegalArgumentException ex) {
    // Syntax error in the replacement text (unescaped $ signs?)
} catch (IndexOutOfBoundsException ex) {
    // Non-existent backreference used the replacement text
}</pre>
<pre>Pattern regex =3D Pattern.compile("before");
Matcher regexMatcher =3D regex.matcher(subjectString);
String resultString =3D regexMatcher.replaceAll("after");</pre>
<pre>String resultString =3D null;
try {
    Pattern regex =3D Pattern.compile("before");
    Matcher regexMatcher =3D regex.matcher(subjectString);
    try {
        resultString =3D regexMatcher.replaceAll("after");
    } catch (IllegalArgumentException ex) {
        // Syntax error in the replacement text (unescaped $ signs?)
    } catch (IndexOutOfBoundsException ex) {
        // Non-existent backreference used the replacement text
    }
} catch (PatternSyntaxException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>JavaScript</h4>
<pre>result =3D subject.replace(/before/g, "after");</pre>
<h4>PHP</h4>
<pre>$result =3D preg_replace('/before/', 'after', $subject);</pre>
<h4>Perl</h4>
<pre>s/before/after/g;</pre>
<pre>$subject =3D~ s/before/after/g;</pre>
<pre>($result =3D $subject) =3D~ s/before/after/g;</pre>
<h4>Python</h4>
<pre>result =3D re.sub("before", "after", subject)</pre>
<pre>reobj =3D re.compile("before")
result =3D reobj.sub("after", subject)</pre>
<h4>Ruby</h4>
<pre>result =3D subject.gsub(/before/, 'after')</pre>
<h3>Discussion</h3>
<h4>PHP</h4>
<pre>$regex[0] =3D '/a/';
$regex[1] =3D '/b/';
$regex[2] =3D '/c/';
$replace[2] =3D '3';
$replace[1] =3D '2';
$replace[0] =3D '1';

echo preg_replace($regex, $replace, "abc");
ksort($replace);
echo preg_replace($regex, $replace, "abc");</pre>
<h2>3.15. Replace Matches Reusing Parts of the Match</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString =3D Regex.Replace(subjectString, @"(\w+)=3D(\w+)",
                                                   "$2=3D$1");</pre>
<pre>Regex regexObj =3D new Regex(@"(\w+)=3D(\w+)");
string resultString =3D regexObj.Replace(subjectString, "$2=3D$1");</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString =3D Regex.Replace(SubjectString, "(\w+)=3D(\w+)", "$2=
=3D$1")</pre>
<pre>Dim RegexObj As New Regex("(\w+)=3D(\w+)")
Dim ResultString =3D RegexObj.Replace(SubjectString, "$2=3D$1")</pre>
<h4>Java</h4>
<pre>String resultString =3D subjectString.replaceAll("(\\w+)=3D(\\w+)", "$=
2=3D$1");</pre>
<pre>Pattern regex =3D Pattern.compile("(\\w+)=3D(\\w+)");
Matcher regexMatcher =3D regex.matcher(subjectString);
String resultString =3D regexMatcher.replaceAll("$2=3D$1");</pre>
<h4>JavaScript</h4>
<pre>result =3D subject.replace(/(\w+)=3D(\w+)/g, "$2=3D$1");</pre>
<h4>PHP</h4>
<pre>$result =3D preg_replace('/(\w+)=3D(\w+)/', '$2=3D$1', $subject);</pre=
>
<h4>Perl</h4>
<pre>$subject =3D~ s/(\w+)=3D(\w+)/$2=3D$1/g;</pre>
<h4>Python</h4>
<pre>result =3D re.sub(r"(\w+)=3D(\w+)", r"\2=3D\1", subject)</pre>
<pre>reobj =3D re.compile(r"(\w+)=3D(\w+)")
result =3D reobj.sub(r"\2=3D\1", subject)</pre>
<h4>Ruby</h4>
<pre>result =3D subject.gsub(/(\w+)=3D(\w+)/, '\2=3D\1')</pre>
<h3>Named Capture</h3>
<h4>C#</h4>
<pre>string resultString =3D Regex.Replace(subjectString,
                      @"(?&lt;left&gt;\w+)=3D(?&lt;right&gt;\w+)", "${right=
}=3D${left}");</pre>
<pre>Regex regexObj =3D new Regex(@"(?&lt;left&gt;\w+)=3D(?&lt;right&gt;\w+=
)");
string resultString =3D regexObj.Replace(subjectString, "${right}=3D${left}=
");</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString =3D Regex.Replace(SubjectString,
                   "(?&lt;left&gt;\w+)=3D(?&lt;right&gt;\w+)", "${right}=3D=
${left}")</pre>
<pre>Dim RegexObj As New Regex("(?&lt;left&gt;\w+)=3D(?&lt;right&gt;\w+)")
Dim ResultString =3D RegexObj.Replace(SubjectString, "${right}=3D${left}")<=
/pre>
<h4>Java 7</h4>
<pre>String resultString =3D subjectString.replaceAll(
                      "(?&lt;left&gt;\\w+)=3D(?&lt;right&gt;\\w+)", "${righ=
t}=3D${left}");</pre>
<pre>Pattern regex =3D Pattern.compile("(?&lt;left&gt;\\w+)=3D(?&lt;right&g=
t;\\w+)");
Matcher regexMatcher =3D regex.matcher(subjectString);
String resultString =3D regexMatcher.replaceAll("${right}=3D${left}");</pre=
>
<h4>XRegExp</h4>
<pre>var re =3D XRegExp("(?&lt;left&gt;\\w+)=3D(?&lt;right&gt;\\w+)", "g");
var result =3D XRegExp.replace(subject, re, "${right}=3D${left}");</pre>
<h4>PHP</h4>
<pre>$result =3D preg_replace('/(?P&lt;left&gt;\w+)=3D(?P&lt;right&gt;\w+)/=
',
                       '$2=3D$1', $subject);</pre>
<h4>Perl</h4>
<pre>$subject =3D~ s/(?&lt;left&gt;\w+)=3D(?&lt;right&gt;\w+)/$+{right}=3D$=
+{left}/g;</pre>
<h4>Python</h4>
<pre>result =3D re.sub(r"(?P&lt;left&gt;\w+)=3D(?P&lt;right&gt;\w+)", r"\g&=
lt;right&gt;=3D\g&lt;left&gt;",
                subject)</pre>
<pre>reobj =3D re.compile(r"(?P&lt;left&gt;\w+)=3D(?P&lt;right&gt;\w+)")
result =3D reobj.sub(r"\g&lt;right&gt;=3D\g&lt;left&gt;", subject)</pre>
<h4>Ruby</h4>
<pre>result =3D subject.gsub(/(?&lt;left&gt;\w+)=3D(?&lt;right&gt;\w+)/, '\=
k&lt;left&gt;=3D\k&lt;right&gt;')</pre>
<h2>3.16. Replace Matches with Replacements Generated in Code</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString =3D Regex.Replace(subjectString, @"\d+",
                      new MatchEvaluator(ComputeReplacement));</pre>
<pre>Regex regexObj =3D new Regex(@"\d+");
string resultString =3D regexObj.Replace(subjectString,
                      new MatchEvaluator(ComputeReplacement));</pre>
<pre>public String ComputeReplacement(Match matchResult) {
    int twiceasmuch =3D int.Parse(matchResult.Value) * 2;
    return twiceasmuch.ToString();
}</pre>
<h4>VB.NET</h4>
<pre>Dim MyMatchEvaluator As New MatchEvaluator(AddressOf ComputeReplacemen=
t)
Dim ResultString =3D Regex.Replace(SubjectString, "\d+", MyMatchEvaluator)<=
/pre>
<pre>Dim RegexObj As New Regex("\d+")
Dim MyMatchEvaluator As New MatchEvaluator(AddressOf ComputeReplacement)
Dim ResultString =3D RegexObj.Replace(SubjectString, MyMatchEvaluator)</pre=
>
<pre>Public Function ComputeReplacement(ByVal MatchResult As Match) As Stri=
ng
    Dim TwiceAsMuch =3D Int.Parse(MatchResult.Value) * 2;
    Return TwiceAsMuch.ToString();
End Function</pre>
<h4>Java</h4>
<pre>StringBuffer resultString =3D new StringBuffer();
Pattern regex =3D Pattern.compile("\\d+");
Matcher regexMatcher =3D regex.matcher(subjectString);
while (regexMatcher.find()) {
    Integer twiceasmuch =3D Integer.parseInt(regexMatcher.group()) * 2;
    regexMatcher.appendReplacement(resultString, twiceasmuch.toString());
}
regexMatcher.appendTail(resultString);</pre>
<h4>JavaScript</h4>
<pre>var result =3D subject.replace(/\d+/g, function(match) {
    return match * 2;
});</pre>
<h4>PHP</h4>
<pre>$result =3D preg_replace_callback('/\d+/', 'compute_replacement', $sub=
ject);

function compute_replacement($groups) {
    return $groups[0] * 2;
}</pre>
<pre>$result =3D preg_replace_callback(
    '/\d+/',
    create_function(
        '$groups',
        'return $groups[0] * 2;'
    ),
    $subject
);</pre>
<h4>Perl</h4>
<pre>$subject =3D~ s/\d+/$&amp; * 2/eg;</pre>
<h4>Python</h4>
<pre>result =3D re.sub(r"\d+", computereplacement, subject)</pre>
<pre>reobj =3D re.compile(r"\d+")
result =3D reobj.sub(computereplacement, subject)</pre>
<pre>def computereplacement(matchobj):
    return str(int(matchobj.group()) * 2)</pre>
<h4>Ruby</h4>
<pre>result =3D subject.gsub(/\d+/) {|match|
    Integer(match) * 2
}</pre>
<h2>3.17. Replace All Matches Within the Matches of </h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>Regex outerRegex =3D new Regex("&lt;b&gt;.*?&lt;/b&gt;", RegexOptions.=
Singleline);
Regex innerRegex =3D new Regex("before");
string resultString =3D outerRegex.Replace(subjectString,
                      new MatchEvaluator(ComputeReplacement));

public String ComputeReplacement(Match matchResult) {
    // Run the inner search-and-replace on each match of the outer regex
    return innerRegex.Replace(matchResult.Value, "after");
}</pre>
<h4>VB.NET</h4>
<pre>Dim OuterRegex As New Regex("&lt;b&gt;.*?&lt;/b&gt;", RegexOptions.Sin=
gleline)
Dim InnerRegex As New Regex("before")
Dim MyMatchEvaluator As New MatchEvaluator(AddressOf ComputeReplacement)
Dim ResultString =3D OuterRegex.Replace(SubjectString, MyMatchEvaluator)

Public Function ComputeReplacement(ByVal MatchResult As Match) As String
    'Run the inner search-and-replace on each match of the outer regex
    Return InnerRegex.Replace(MatchResult.Value, "after");
End Function</pre>
<h4>Java</h4>
<pre>StringBuffer resultString =3D new StringBuffer();
Pattern outerRegex =3D Pattern.compile("&lt;b&gt;.*?&lt;/b&gt;");
Pattern innerRegex =3D Pattern.compile("before");
Matcher outerMatcher =3D outerRegex.matcher(subjectString);
while (outerMatcher.find()) {
    outerMatcher.appendReplacement(resultString,
      innerRegex.matcher(outerMatcher.group()).replaceAll("after"));
}
outerMatcher.appendTail(resultString);</pre>
<h4>JavaScript</h4>
<pre>var result =3D subject.replace(/&lt;b&gt;.*?&lt;\/b&gt;/g, function(ma=
tch) {
    return match.replace(/before/g, "after");
});</pre>
<h4>PHP</h4>
<pre>$result =3D preg_replace_callback('%&lt;b&gt;.*?&lt;/b&gt;%',
                                replace_within_tag, $subject);

function replace_within_tag($groups) {
    return preg_replace('/before/', 'after', $groups[0]);
}</pre>
<h4>Perl</h4>
<pre>$subject =3D~ s%&lt;b&gt;.*?&lt;/b&gt;%($match =3D $&amp;) =3D~ s/befo=
re/after/g; $match;%eg;</pre>
<h4>Python</h4>
<pre>innerre =3D re.compile("before")
def replacewithin(matchobj):
    return innerre.sub("after", matchobj.group())

result =3D re.sub("&lt;b&gt;.*?&lt;/b&gt;", replacewithin, subject)</pre>
<h4>Ruby</h4>
<pre>innerre =3D /before/
result =3D subject.gsub(/&lt;b&gt;.*?&lt;\/b&gt;/) {|match|
    match.gsub(innerre, 'after')
}</pre>
<h2>3.18. Replace All Matches Between the Matches of Another Regex</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string resultString =3D null;
Regex outerRegex =3D new Regex("&lt;[^&lt;&gt;]*&gt;");
Regex innerRegex =3D new Regex("\"([^\"]*)\"");
// Find the first section
int lastIndex =3D 0;
Match outerMatch =3D outerRegex.Match(subjectString);
while (outerMatch.Success) {
    // Search and replace through the text between this match,
    // and the previous one
	string textBetween =3D
	    subjectString.Substring(lastIndex, outerMatch.Index - lastIndex);
	resultString +=3D innerRegex.Replace(textBetween, "\u201C$1\u201D");
	lastIndex =3D outerMatch.Index + outerMatch.Length;
	// Copy the text in the section unchanged
	resultString +=3D outerMatch.Value;
	// Find the next section
	outerMatch =3D outerMatch.NextMatch();
}
// Search and replace through the remainder after the last regex match
string textAfter =3D subjectString.Substring(lastIndex,
                   subjectString.Length - lastIndex);
resultString +=3D innerRegex.Replace(textAfter, "\u201C$1\u201D");</pre>
<h4>VB.NET</h4>
<pre>Dim ResultString As String =3D Nothing
Dim OuterRegex As New Regex("&lt;[^&lt;&gt;]*&gt;")
Dim InnerRegex As New Regex("""([^""]*)""")
'Find the first section
Dim LastIndex =3D 0
Dim OuterMatch =3D OuterRegex.Match(SubjectString)
While OuterMatch.Success
    'Search and replace through the text between this match,=20
    'and the previous one
    Dim TextBetween =3D SubjectString.Substring(LastIndex,=20
                      OuterMatch.Index - LastIndex);
    ResultString +=3D InnerRegex.Replace(TextBetween,=20
                    ChrW(&amp;H201C) + "$1" + ChrW(&amp;H201D))
    LastIndex =3D OuterMatch.Index + OuterMatch.Length
    'Copy the text in the section unchanged
    ResultString +=3D OuterMatch.Value
    'Find the next section
    OuterMatch =3D OuterMatch.NextMatch
End While
'Search and replace through the remainder after the last regex match
Dim TextAfter =3D SubjectString.Substring(LastIndex,
                                        SubjectString.Length - LastIndex);
ResultString +=3D InnerRegex.Replace(TextAfter,=20
                ChrW(&amp;H201C) + "$1" + ChrW(&amp;H201D))</pre>
<h4>Java</h4>
<pre>StringBuffer resultString =3D new StringBuffer();
Pattern outerRegex =3D Pattern.compile("&lt;[^&lt;&gt;]*&gt;");
Pattern innerRegex =3D Pattern.compile("\"([^\"]*)\"");
Matcher outerMatcher =3D outerRegex.matcher(subjectString);
int lastIndex =3D 0;
while (outerMatcher.find()) {
    // Search and replace through the text between this match,
    // and the previous one
    String textBetween =3D subjectString.substring(lastIndex,
                                                 outerMatcher.start());
    Matcher innerMatcher =3D innerRegex.matcher(textBetween);
    resultString.append(innerMatcher.replaceAll("\u201C$1\u201D"));
    lastIndex =3D outerMatcher.end();
    // Append the regex match itself unchanged
    resultString.append(outerMatcher.group());
}
// Search and replace through the remainder after the last regex match
String textAfter =3D subjectString.substring(lastIndex);
Matcher innerMatcher =3D innerRegex.matcher(textAfter);
resultString.append(innerMatcher.replaceAll("\u201C$1\u201D"));</pre>
<h4>JavaScript</h4>
<pre>var result =3D "";
var outerRegex =3D /&lt;[^&lt;&gt;]*&gt;/g;
var innerRegex =3D /"([^"]*)"/g;
var outerMatch =3D null;
var lastIndex =3D 0;
while (outerMatch =3D outerRegex.exec(subject)) {
    if (outerMatch.index =3D=3D outerRegex.lastIndex) outerRegex.lastIndex+=
+;
    // Search and replace through the text between this match,
    // and the previous one
    var textBetween =3D subject.slice(lastIndex, outerMatch.index);
    result +=3D textBetween.replace(innerRegex, "\u201C$1\u201D");
    lastIndex =3D outerMatch.index + outerMatch[0].length;
    // Append the regex match itself unchanged
    result +=3D outerMatch[0];
}
// Search and replace through the remainder after the last regex match
var textAfter =3D subject.slice(lastIndex);
result +=3D textAfter.replace(innerRegex, "\u201C$1\u201D");</pre>
<h4>PHP</h4>
<pre>$result =3D '';
$lastindex =3D 0;
while (preg_match('/&lt;[^&lt;&gt;]*&gt;/', $subject, $groups, PREG_OFFSET_=
CAPTURE,=20
                 $lastindex)) {
    $matchstart =3D $groups[0][1];
    $matchlength =3D strlen($groups[0][0]);
    // Search and replace through the text between this match,
    // and the previous one
    $textbetween =3D substr($subject, $lastindex, $matchstart-$lastindex);
    $result .=3D preg_replace('/"([^"]*)"/', '=E2=80=9C$1=E2=80=9D', $textb=
etween);
    // Append the regex match itself unchanged
    $result .=3D $groups[0][0];
    // Move the starting position for the next match
    $lastindex =3D $matchstart + $matchlength;
    if ($matchlength =3D=3D 0) {
        // Don't get stuck in an infinite loop
        // if the regex allows zero-length matches
        $lastindex++;
    }
}
// Search and replace through the remainder after the last regex match
$textafter =3D substr($subject, $lastindex);
$result .=3D preg_replace('/"([^"]*)"/', '=E2=80=9C$1=E2=80=9D', $textafter=
);</pre>
<h4>Perl</h4>
<pre>use encoding "utf-8";
$result =3D '';
while ($subject =3D~ m/&lt;[^&lt;&gt;]*&gt;/g) {
    $match =3D $&amp;;
    $textafter =3D $';
    ($textbetween =3D $`) =3D~ s/"([^"]*)"/\x{201C}$1\x{201D}/g;
    $result .=3D $textbetween . $match;
}
$textafter =3D~ s/"([^"]*)"/\x{201C}$1\x{201D}/g;
$result .=3D $textafter;</pre>
<h4>Python</h4>
<pre>innerre =3D re.compile('"([^"]*)"')
result =3D "";
lastindex =3D 0;
for outermatch in re.finditer("&lt;[^&lt;&gt;]*&gt;", subject):
    # Search and replace through the text between this match,
    # and the previous one
    textbetween =3D subject[lastindex:outermatch.start()]
    result +=3D innerre.sub(u"\u201C\\1\u201D", textbetween)
    lastindex =3D outermatch.end()
    # Append the regex match itself unchanged
    result +=3D outermatch.group()
# Search and replace through the remainder after the last regex match
textafter =3D subject[lastindex:]
result +=3D innerre.sub(u"\u201C\\1\u201D", textafter)</pre>
<h4>Ruby</h4>
<pre>result =3D '';
textafter =3D ''
subject.scan(/&lt;[^&lt;&gt;]*&gt;/) {|match|
    textafter =3D $'
    textbetween =3D $`.gsub(/"([^"]*)"/, '=E2=80=9C\1=E2=80=9D')
    result +=3D textbetween + match
}
result +=3D textafter.gsub(/"([^"]*)"/, '=E2=80=9C\1=E2=80=9D')</pre>
<h3>Discussion</h3>
<h4>Python</h4>
<pre>print result.encode('1252')</pre>
<h2>3.19. Split a String</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string[] splitArray =3D Regex.Split(subjectString, "&lt;[^&lt;&gt;]*&g=
t;");</pre>
<pre>string[] splitArray =3D null;
try {
    splitArray =3D Regex.Split(subjectString, "&lt;[^&lt;&gt;]*&gt;");
} catch (ArgumentNullException ex) {
     // Cannot pass null as the regular expression or subject string
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<pre>Regex regexObj =3D new Regex("&lt;[^&lt;&gt;]*&gt;");
string[] splitArray =3D regexObj.Split(subjectString);</pre>
<pre>string[] splitArray =3D null;
try {
    Regex regexObj =3D new Regex("&lt;[^&lt;&gt;]*&gt;");
    try {
        splitArray =3D regexObj.Split(subjectString);
    } catch (ArgumentNullException ex) {
        // Cannot pass null as the subject string
    }
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>VB.NET</h4>
<pre>Dim SplitArray =3D Regex.Split(SubjectString, "&lt;[^&lt;&gt;]*&gt;")<=
/pre>
<pre>Dim SplitArray As String()
Try
    SplitArray =3D Regex.Split(SubjectString, "&lt;[^&lt;&gt;]*&gt;")
Catch ex As ArgumentNullException
    'Cannot pass null as the regular expression or subject string
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<pre>Dim RegexObj As New Regex("&lt;[^&lt;&gt;]*&gt;")
Dim SplitArray =3D RegexObj.Split(SubjectString)</pre>
<pre>Dim SplitArray As String()
Try
    Dim RegexObj As New Regex("&lt;[^&lt;&gt;]*&gt;")
    Try
        SplitArray =3D RegexObj.Split(SubjectString)
    Catch ex As ArgumentNullException
        'Cannot pass null as the subject string
    End Try
Catch ex As ArgumentException
    'Syntax error in the regular expression
End Try</pre>
<h4>Java</h4>
<pre>String[] splitArray =3D subjectString.split("&lt;[^&lt;&gt;]*&gt;");</=
pre>
<pre>try {
    String[] splitArray =3D subjectString.split("&lt;[^&lt;&gt;]*&gt;");
} catch (PatternSyntaxException ex) {
    // Syntax error in the regular expression
}</pre>
<pre>Pattern regex =3D Pattern.compile("&lt;[^&lt;&gt;]*&gt;");
String[] splitArray =3D regex.split(subjectString);</pre>
<pre>String[] splitArray =3D null;
try {
    Pattern regex =3D Pattern.compile("&lt;[^&lt;&gt;]*&gt;");
    splitArray =3D regex.split(subjectString);
} catch (ArgumentException ex) {
    // Syntax error in the regular expression
}</pre>
<h4>JavaScript</h4>
<pre>result =3D subject.split(/&lt;[^&lt;&gt;]*&gt;/);</pre>
<h4>XRegExp</h4>
<pre>result =3D XRegExp.split(subject, /&lt;[^&lt;&gt;]*&gt;/);</pre>
<h4>PHP</h4>
<pre>$result =3D preg_split('/&lt;[^&lt;&gt;]*&gt;/', $subject);</pre>
<h4>Perl</h4>
<pre>@result =3D split(m/&lt;[^&lt;&gt;]*&gt;/, $subject);</pre>
<h4>Python</h4>
<pre>result =3D re.split("&lt;[^&lt;&gt;]*&gt;", subject))</pre>
<pre>reobj =3D re.compile("&lt;[^&lt;&gt;]*&gt;")
result =3D reobj.split(subject)</pre>
<h4>Ruby</h4>
<pre>result =3D subject.split(/&lt;[^&lt;&gt;]*&gt;/)</pre>
<h2>3.20. Split a String, Keeping the Regex Matches</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string[] splitArray =3D Regex.Split(subjectString, "(&lt;[^&lt;&gt;]*&=
gt;)");</pre>
<pre>Regex regexObj =3D new Regex("(&lt;[^&lt;&gt;]*&gt;)");
string[] splitArray =3D regexObj.Split(subjectString);</pre>
<h4>VB.NET</h4>
<pre>Dim SplitArray =3D Regex.Split(SubjectString, "(&lt;[^&lt;&gt;]*&gt;)"=
)</pre>
<pre>Dim RegexObj As New Regex("(&lt;[^&lt;&gt;]*&gt;)")
Dim SplitArray =3D RegexObj.Split(SubjectString)</pre>
<h4>Java</h4>
<pre>List&lt;String&gt; resultList =3D new ArrayList&lt;String&gt;();
Pattern regex =3D Pattern.compile("&lt;[^&lt;&gt;]*&gt;");
Matcher regexMatcher =3D regex.matcher(subjectString);
int lastIndex =3D 0;
while (regexMatcher.find()) {
    resultList.add(subjectString.substring(lastIndex,
                                           regexMatcher.start()));
    resultList.add(regexMatcher.group());
    lastIndex =3D regexMatcher.end();
}
resultList.add(subjectString.substring(lastIndex));</pre>
<h4>JavaScript</h4>
<pre>result =3D subject.split(/(&lt;[^&lt;&gt;]*&gt;)/);</pre>
<h4>XRegExp</h4>
<pre>result =3D XRegExp.split(subject, /(&lt;[^&lt;&gt;]*&gt;)/);</pre>
<h4>PHP</h4>
<pre>$result =3D preg_split('/(&lt;[^&lt;&gt;]*&gt;)/', $subject, -1,
                     PREG_SPLIT_DELIM_CAPTURE);</pre>
<h4>Perl</h4>
<pre>@result =3D split(m/(&lt;[^&lt;&gt;]*&gt;)/, $subject);</pre>
<h4>Python</h4>
<pre>result =3D re.split("(&lt;[^&lt;&gt;]*&gt;)", subject))</pre>
<pre>reobj =3D re.compile("(&lt;[^&lt;&gt;]*&gt;)")
result =3D reobj.split(subject)</pre>
<h4>Ruby</h4>
<pre>list =3D []
lastindex =3D 0;
subject.scan(/&lt;[^&lt;&gt;]*&gt;/) {|match|
    list &lt;&lt; subject[lastindex..$~.begin(0)-1];
    list &lt;&lt; $&amp;
    lastindex =3D $~.end(0)
}
list &lt;&lt; subject[lastindex..subject.length()]</pre>
<h2>3.21. Search Line by Line</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>string[] lines =3D Regex.Split(subjectString, "\r?\n");</pre>
<pre>Regex regexObj =3D new Regex("regex pattern");
for (int i =3D 0; i &lt; lines.Length; i++) {
    if (regexObj.IsMatch(lines[i])) {
        // The regex matches lines[i]
    } else {
        // The regex does not match lines[i]
    }
}</pre>
<h4>VB.NET</h4>
<pre>Dim Lines =3D Regex.Split(SubjectString, "\r?\n")</pre>
<pre>Dim RegexObj As New Regex("regex pattern")
For i As Integer =3D 0 To Lines.Length - 1
    If RegexObj.IsMatch(Lines(i)) Then
        'The regex matches Lines(i)
    Else
        'The regex does not match Lines(i)
    End If
Next</pre>
<h4>Java</h4>
<pre>String[] lines =3D subjectString.split("\r?\n");</pre>
<pre>Pattern regex =3D Pattern.compile("regex pattern");
Matcher regexMatcher =3D regex.matcher("");
for (int i =3D 0; i &lt; lines.length; i++) {
    regexMatcher.reset(lines[i]);
    if (regexMatcher.find()) {
        // The regex matches lines[i]
    } else {
        // The regex does not match lines[i]
    }
}</pre>
<h4>JavaScript</h4>
<pre>var lines =3D subject.split(/\r?\n/);</pre>
<pre>var regexp =3D /regex pattern/;
for (var i =3D 0; i &lt; lines.length; i++) {
    if (lines[i].match(regexp)) {
        // The regex matches lines[i]
    } else {
        // The regex does not match lines[i]
    }
}</pre>
<h4>PHP</h4>
<pre>$lines =3D preg_split('/\r?\n/', $subject)</pre>
<pre>foreach ($lines as $line) {
    if (preg_match('/regex pattern/', $line)) {
        // The regex matches $line
    } else {
        // The regex does not match $line
    }
}</pre>
<h4>Perl</h4>
<pre>@lines =3D split(m/\r?\n/, $subject)</pre>
<pre>foreach $line (@lines) {
    if ($line =3D~ m/regex pattern/) {
        # The regex matches $line
    } else {
        # The regex does not match $line
    }
}</pre>
<h4>Python</h4>
<pre>lines =3D re.split("\r?\n", subject)</pre>
<pre>reobj =3D re.compile("regex pattern")
for line in lines[:]:
    if reobj.search(line):
        # The regex matches line
    else:
        # The regex does not match line</pre>
<h4>Ruby</h4>
<pre>lines =3D subject.split(/\r?\n/)</pre>
<pre>re =3D /regex pattern/
lines.each { |line|
    if line =3D~ re
        # The regex matches line
    else
        # The regex does not match line
}</pre>
<h2>3.22. Construct a Parser</h2>
<h3>Problem</h3>
<pre>table %First table%
  row cell %A1% cell %B1% cell%C1%cell%D1%
  ROW row CELL %The previous row was blank%
  cell %B3%
  row
    cell %A4% %second line%
    cEll %B4%
         %second line%
    cell %C4
second line%
  row cell %%%string%%%
    cell %%
    cell %%%%
    cell %%%%%%</pre>
<h3>Solution</h3>
<h4>C#</h4>
<pre>static RECTable ImportTable(string fileContents) {
  RECTable table =3D null;
  RECRow row =3D null;
  RECCell cell =3D null;
  Regex regexObj =3D new Regex(
      @"  \b(?&lt;keyword&gt;table|row|cell)\b
      | %(?&lt;string&gt;[^%]*(?:%%[^%]*)*)%
      | (?&lt;error&gt;\S+)",
    RegexOptions.IgnoreCase | RegexOptions.IgnorePatternWhitespace);
  Match match =3D regexObj.Match(fileContents);
  while (match.Success) {
    if (match.Groups["keyword"].Success) {
      string keyword =3D match.Groups["keyword"].Value.ToLower();
      if (keyword =3D=3D "table") {
        table =3D new RECTable();
        row =3D null;
        cell =3D null;
      } else if (keyword =3D=3D "row") {
        if (table =3D=3D null)
          throw new Exception("Invalid data: row without table");
        row =3D table.addRow();
        cell =3D null;
      } else if (keyword =3D=3D "cell") {
        if (row =3D=3D null)
          throw new Exception("Invalid data: cell without row");
        cell =3D row.addCell();
      } else {
        throw new Exception("Parser bug: unknown keyword");
      }
    } else if (match.Groups["string"].Success) {
      string content =3D match.Groups["string"].Value.Replace("%%", "%");
      if (cell !=3D null)
        cell.addContent(content);
      else if (row !=3D null)
        throw new Exception("Invalid data: string after row keyword");
      else if (table !=3D null)
        table.addCaption(content);
      else
        throw new Exception("Invalid data: string before table keyword");
    } else if (match.Groups["error"].Success) {
      throw new Exception("Invalid data: " + match.Groups["error"].Value);
    } else {
      throw new Exception("Parser bug: no capturing group matched");
    }
    match =3D match.NextMatch();
  }
  if (table =3D=3D null)
    throw new Exception("Invalid data: table keyword missing");
  return table;
}</pre>
<h4>VB.NET</h4>
<pre>Function ImportTable(ByVal FileContents As String)
  Dim Table As RECTable =3D Nothing
  Dim Row As RECRow =3D Nothing
  Dim Cell As RECCell =3D Nothing
  Dim RegexObj As New Regex(
      "  \b(?&lt;keyword&gt;table|row|cell)\b" &amp; _
      "| %(?&lt;string&gt;[^%]*(?:%%[^%]*)*)%" &amp; _
      "| (?&lt;error&gt;\S+)",
      RegexOptions.IgnoreCase Or RegexOptions.IgnorePatternWhitespace)
  Dim MatchResults As Match =3D RegexObj.Match(FileContents)
  While MatchResults.Success
    If MatchResults.Groups("keyword").Success Then
      Dim Keyword As String =3D MatchResults.Groups("keyword").Value
      Keyword =3D Keyword.ToLower()
      If Keyword =3D "table" Then
        Table =3D New RECTable
        Row =3D Nothing
        Cell =3D Nothing
      ElseIf Keyword =3D "row" Then
        If Table Is Nothing Then
          Throw New Exception("Invalid data: row without table")
        End If
        Row =3D Table.addRow
        Cell =3D Nothing
      ElseIf Keyword =3D "cell" Then
        If Row Is Nothing Then
          Throw New Exception("Invalid data: cell without row")
        End If
        Cell =3D Row.addCell
      Else
        Throw New Exception("Parser bug: unknown keyword")
      End If
    ElseIf MatchResults.Groups("string").Success Then
      Dim Content As String =3D MatchResults.Groups("string").Value
      Content =3D Content.Replace("%%", "%")
      If Cell IsNot Nothing Then
        Cell.addContent(Content)
      ElseIf Row IsNot Nothing Then
        Throw New Exception("Invalid data: string after row keyword")
      ElseIf Table IsNot Nothing Then
        Table.addCaption(Content)
      Else
        Throw New Exception("Invalid data: string before table keyword")
      End If
    ElseIf MatchResults.Groups("error").Success Then
      Throw New Exception("Invalid data")
    Else
      Throw New Exception("Parser bug: no capturing group matched")
    End If
    MatchResults =3D MatchResults.NextMatch()
  End While
  If Table Is Nothing Then
    Throw New Exception("Invalid data: table keyword missing")
  End If
  Return Table
End Function</pre>
<h4>Java</h4>
<pre>RECTable ImportTable(String fileContents) throws Exception {
  RECTable table =3D null;
  RECRow row =3D null;
  RECCell cell =3D null;
  final int groupkeyword =3D 1;
  final int groupstring =3D 2;
  final int grouperror =3D 3;
  Pattern regex =3D Pattern.compile(
      "  \\b(table|row|cell)\\b\n" +
      "| %([^%]*(?:%%[^%]*)*)%\n" +
      "| (\\S+)",
      Pattern.CASE_INSENSITIVE | Pattern.COMMENTS);
  Matcher regexMatcher =3D regex.matcher(fileContents);
  while (regexMatcher.find()) {
    if (regexMatcher.start(groupkeyword) &gt;=3D 0) {
      String keyword =3D regexMatcher.group(groupkeyword).toLowerCase();
      if (keyword.equals("table")) {
        table =3D new RECTable();
        row =3D null;
        cell =3D null;
      } else if (keyword.equals("row")) {
        if (table =3D=3D null)
          throw new Exception("Invalid data: row without table");
        row =3D table.addRow();
        cell =3D null;
      } else if (keyword.equals("cell")) {
        if (row =3D=3D null)
          throw new Exception("Invalid data: cell without row");
        cell =3D row.addCell();
      } else {
        throw new Exception("Parser bug: unknown keyword");
      }
    } else if (regexMatcher.start(groupstring) &gt;=3D 0) {
      String content =3D regexMatcher.group(groupstring);
      content =3D content.replaceAll("%%", "%");
      if (cell !=3D null)
        cell.addContent(content);
      else if (row !=3D null)
        throw new Exception("Invalid data: String after row keyword");
      else if (table !=3D null)
        table.addCaption(content);
      else
        throw new Exception("Invalid data: String before table keyword");
    } else if (regexMatcher.start(grouperror) &gt;=3D 0) {
      throw new Exception("Invalid data: " +=20
                          regexMatcher.group(grouperror));
    } else {
      throw new Exception("Parser bug: no capturing group matched");
    }
  }
  if (table =3D=3D null)
    throw new Exception("Invalid data: table keyword missing");
  return table;
}</pre>
<h4>JavaScript</h4>
<pre>function importTable(fileContents) {
  var table =3D null;
  var row =3D null;
  var cell =3D null;
  var groupkeyword =3D 1;
  var groupstring =3D 2;
  var grouperror =3D 3;
  var myregexp =3D /\b(table|row|cell)\b|%([^%]*(?:%%[^%]*)*)%|(\S+)/ig;
  var match;
  var keyword;
  var content;
  while (match =3D myregexp.exec(fileContents)) {
    if (match[groupkeyword] !=3D=3D undefined) {
      keyword =3D match[groupkeyword].toLowerCase();
      if (keyword =3D=3D "table") {
        table =3D new RECTable();
        row =3D null;
        cell =3D null;
      } else if (keyword =3D=3D "row") {
        if (!table)
          throw new Error("Invalid data: row without table");
        row =3D table.addRow();
        cell =3D null;
      } else if (keyword =3D=3D "cell") {
        if (!row)
          throw new Error("Invalid data: cell without row");
        cell =3D row.addCell();
      } else {
        throw new Error("Parser bug: unknown keyword");
      }
    } else if (match[groupstring] !=3D=3D undefined) {
      content =3D match[groupstring].replace(/%%/g, "%");
      if (cell)
        cell.addContent(content);
      else if (row)
        throw new Error("Invalid data: string after row keyword");
      else if (table)
        table.addCaption(content);
      else
        throw new Error("Invalid data: string before table keyword");
    } else if (match[grouperror] !=3D=3D undefined) {
      throw new Error("Invalid data: " + match[grouperror]);
    } else {
      throw new Error("Parser bug: no capturing group matched");
    }
  }
  if (!table)
    throw new Error("Invalid data: table keyword missing");
  return table;
}</pre>
<h4>XRegExp</h4>
<pre>function importTable(fileContents) {
  var table =3D null;
  var row =3D null;
  var cell =3D null;
  var myregexp =3D XRegExp("(?ix)\\b(?&lt;keyword&gt;table|row|cell)\\b" +
                         "   | %(?&lt;string&gt;[^%]*(?:%%[^%]*)*)%" +
                         "   | (?&lt;error&gt;\\S+)");
  XRegExp.forEach(fileContents, myregexp, function(match) {
    var keyword;
    var content;
    if (match.keyword !=3D=3D undefined) {
      keyword =3D match.keyword.toLowerCase();
      if (keyword =3D=3D "table") {
        table =3D new RECTable();
        row =3D null;
        cell =3D null;
      } else if (keyword =3D=3D "row") {
        if (!table)
          throw new Error("Invalid data: row without table");
        row =3D table.addRow();
        cell =3D null;
      } else if (keyword =3D=3D "cell") {
        if (!row)
          throw new Error("Invalid data: cell without row");
        cell =3D row.addCell();
      } else {
        throw new Error("Parser bug: unknown keyword");
      }
    } else if (match.string !=3D=3D undefined) {
      content =3D match.string.replace(/%%/g, "%");
      if (cell)
        cell.addContent(content);
      else if (row)
        throw new Error("Invalid data: string after row keyword");
      else if (table)
        table.addCaption(content);
      else
        throw new Error("Invalid data: string before table keyword");
    } else if (match.error !=3D=3D undefined) {
      throw new Error("Invalid data: " + match.error);
    } else {
      throw new Error("Parser bug: no capturing group matched");
    }
  });
  if (!table)
    throw new Error("Invalid data: table keyword missing");
  return table;
}</pre>
<h4>Perl</h4>
<pre>sub importtable {
  my $filecontents =3D shift;
  my $table;
  my $row;
  my $cell;
  while ($filecontents =3D~=20
          m/  \b(table|row|cell)\b
          | %([^%]*(?:%%[^%]*)*)%
          | (\S+)/ixg) {
    if (defined($1)) { # Keyword
      my $keyword =3D lc($1);
      if ($keyword eq "table") {
        $table =3D new RECTable();
        undef $row;
        undef $cell;
      } elsif ($keyword eq "row") {
        if (!defined($table)) {
          die "Invalid data: row without table";
        }
        $row =3D $table-&gt;addRow();
        undef $cell;
      } elsif ($keyword eq "cell") {
        if (!defined($row)) {
          die "Invalid data: cell without row";
        }
        $cell =3D $row-&gt;addCell();
      } else {
        die "Parser bug: unknown keyword";
      }
    } elsif (defined($2)) { # String
      my $content =3D $2;
      $content =3D~ s/%%/%/g;
      if (defined($cell)) {
        $cell-&gt;addContent($content);
      } elsif (defined($row)) {
        die "Invalid data: string after row keyword";
      } elsif (defined($table)) {
        $table-&gt;addCaption($content);
      } else {
        die "Invalid data: string before table keyword";
      }
    } elsif (defined($3)) { # Error
      die "Invalid data: $3";
    } else {
      die "Parser bug: no capturing group matched";
    }
  }
  if (!defined(table)) {
    die "Invalid data: table keyword missing";
  }
  return table;
}</pre>
<h4>Python</h4>
<pre>def importtable(filecontents):
  table =3D None
  row =3D None
  cell =3D None
  for match in re.finditer(
    r"""(?ix)\b(?P&lt;keyword&gt;table|row|cell)\b
             | %(?P&lt;string&gt;[^%]*(?:%%[^%]*)*)%
             | (?P&lt;error&gt;\S+)""", filecontents):
    if match.group("keyword") !=3D None:
      keyword =3D match.group("keyword").lower()
      if keyword =3D=3D "table":
        table =3D RECTable()
        row =3D None
        cell =3D None
      elif keyword =3D=3D "row":
        if table =3D=3D None:
          raise Exception("Invalid data: row without table")
        row =3D table.addRow()
        cell =3D None
      elif keyword =3D=3D "cell":
        if row =3D=3D None:
          raise Exception("Invalid data: cell without row")
        cell =3D row.addCell()
      else:
        raise Exception("Parser bug: unknown keyword")
    elif match.group("string") !=3D None:
      content =3D match.group("string").replace("%%", "%")
      if cell !=3D None:
        cell.addContent(content)
      elif row !=3D None:
        raise Exception("Invalid data: string after row keyword")
      elif table !=3D None:
        table.addCaption(content)
      else:
        raise Exception("Invalid data: string before table keyword")
    elif match.group("error") !=3D None:
      raise Exception("Invalid data: " + match.group("error"))
    else:
      raise Exception("Parser bug: no capturing group matched")
  if table =3D=3D None:
    raise Exception("Invalid data: table keyword missing")
  return table</pre>
<h4>PHP</h4>
<pre>function importTable($fileContents) {
  preg_match_all(
    '/  \b(?P&lt;keyword&gt;table|row|cell)\b
      | (?P&lt;string&gt;%[^%]*(?:%%[^%]*)*%)
      | (?P&lt;error&gt;\S+)/ix',
    $fileContents, $matches, PREG_PATTERN_ORDER);
  $table =3D NULL;
  $row =3D NULL;
  $cell =3D NULL;
  for ($i =3D 0; $i &lt; count($matches[0]); $i++) {
    if ($matches['keyword'][$i] !=3D NULL) {
      $keyword =3D strtolower($matches['keyword'][$i]);
      if ($keyword =3D=3D "table") {
        $table =3D new RECTable();
        $row =3D NULL;
        $cell =3D NULL;
      } elseif ($keyword =3D=3D "row") {
        if ($table =3D=3D NULL)
          throw new Exception("Invalid data: row without table");
        $row =3D $table-&gt;addRow();
        $cell =3D NULL;
      } elseif ($keyword =3D=3D "cell") {
        if ($row =3D=3D NULL)
          throw new Exception("Invalid data: cell without row");
        $cell =3D $row-&gt;addCell();
      } else {
        throw new Exception("Parser bug: unknown keyword");
      }
    } elseif ($matches['string'][$i] !=3D NULL) {
      $content =3D $matches['string'][$i];
      $content =3D substr($content, 1, strlen($content)-2);
      $content =3D str_replace('%%', '%', $content);
      if ($cell !=3D NULL)
        $cell-&gt;addContent($content);
      elseif ($row !=3D NULL)
        throw new Exception("Invalid data: string after row keyword");
      elseif ($table !=3D NULL)
        $table-&gt;addCaption($content);
      else
        throw new Exception("Invalid data: string before table keyword");
    } elseif ($matches['error'][$i] !=3D NULL) {
      throw new Exception("Invalid data: " + $matches['error'][$i]);
    } else {
      throw new Exception("Parser bug: no capturing group matched");
    }
  }
  if ($table =3D=3D NULL)
    throw new Exception("Invalid data: table keyword missing");
  return $table;
}</pre>
<h4>Ruby</h4>
<pre>def importtable(filecontents)
  table =3D nil
  row =3D nil
  cell =3D nil
  groupkeyword =3D 0;
  groupstring =3D 1;
  grouperror =3D 2;
  regexp =3D /  \b(table|row|cell)\b
            | %([^%]*(?:%%[^%]*)*)%
            | (\S+)/ix
  filecontents.scan(regexp) do |match|
    if match[groupkeyword]
      keyword =3D match[groupkeyword].downcase
      if keyword =3D=3D "table"
        table =3D RECTable.new()
        row =3D nil
        cell =3D nil
      elsif keyword =3D=3D "row"
        if table.nil?
          raise "Invalid data: row without table"
        end
        row =3D table.addRow()
        cell =3D nil
      elsif keyword =3D=3D "cell"
        if row.nil?
          raise "Invalid data: cell without row"
        end
        cell =3D row.addCell()
      else
        raise "Parser bug: unknown keyword"
      end
    elsif not match[groupstring].nil?
      content =3D match[groupstring].gsub("%%", "%")
      if not cell.nil?
        cell.addContent(content)
      elsif not row.nil?
        raise "Invalid data: string after row keyword"
      elsif not table.nil?
        table.addCaption(content)
      else
        raise "Invalid data: string before table keyword"
      end
    elsif not match[grouperror].nil?
      raise "Invalid data: " + match.group("error")
    else
      raise "Parser bug: no capturing group matched"
    end
  end
  if table.nil?
    raise "Invalid data: table keyword missing"
  end
  return table
end</pre>
<h3>Discussion</h3>
<pre>  \b(?&lt;keyword&gt;table|row|cell)\b
| %(?&lt;string&gt;[^%]*(?:%%[^%]*)*)%
| (?&lt;error&gt;\S+)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>  \b(?P&lt;keyword&gt;table|row|cell)\b
| %(?P&lt;string&gt;[^%]*(?:%%[^%]*)*)%
| (?P&lt;error&gt;\S+)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
        and later, Perl 5.10, Python</p>
<pre>  \b(table|row|cell)\b
| %([^%]*(?:%%[^%]*)*)%
| (\S+)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>\b(table|row|cell)\b|%([^%]*+(?:%%[^%]*+)*+)%|(\S+)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h1>4. Validation and Formatting</h1>
<h2>4.1. Validate Email Addresses</h2>
<h3>Solution</h3>
<h4>Simple</h4>
<pre>^\S+@\S+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A\S+@\S+\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Simple, with restrictions on characters</h4>
<pre>^[A-Z0-9+_.-]+@[A-Z0-9.-]+$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A[A-Z0-9+_.-]+@[A-Z0-9.-]+\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Simple, with all valid local part characters</h4>
<pre>^[A-Z0-9_!#$%&amp;'*+/=3D?`{|}~^.-]+@[A-Z0-9.-]+$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A[A-Z0-9_!#$%&amp;'*+/=3D?`{|}~^.-]+@[A-Z0-9.-]+\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>No leading, trailing, or consecutive dots</h4>
<pre>^[A-Z0-9_!#$%&amp;'*+/=3D?`{|}~^-]+(?:\.[A-Z0-9_!#$%&amp;'*+/=3D?`{|}~=
^-]+)*@[A-Z0-9-]+(?:\.[A-Z0-9-]+)*$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A[A-Z0-9_!#$%&amp;'*+/=3D?`{|}~^-]+(?:\.[A-Z0-9_!#$%&amp;'*+/=3D?`{|}=
~^-]+)*@[A-Z0-9-]+(?:\.[A-Z0-9-]+)*\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Top-level domain has two to six letters</h4>
<pre>^[\w!#$%&amp;'*+/=3D?`{|}~^-]+(?:\.[\w!#$%&amp;'*+/=3D?`{|}~^-]+)*@(?:=
[A-Z0-9-]+\.)+[A-Z]{2,6}$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A[\w!#$%&amp;'*+/=3D?`{|}~^-]+(?:\.[\w!#$%&amp;'*+/=3D?`{|}~^-]+)*@(?=
:[A-Z0-9-]+\.)+[A-Z]{2,6}\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h2>4.2. Validate and Format North American Phone Numbers</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>($1) $2-$3</pre>
<pre>(\1) \2-\3</pre>
<h4>C# example</h4>
<pre>Regex phoneRegex =3D
    new Regex(@"^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$");

if (phoneRegex.IsMatch(subjectString)) {
    string formattedPhoneNumber =3D
        phoneRegex.Replace(subjectString, "($1) $2-$3");
} else {
    // Invalid phone number
}</pre>
<h4>JavaScript example</h4>
<pre>var phoneRegex =3D /^\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$=
/;

if (phoneRegex.test(subjectString)) {
    var formattedPhoneNumber =3D
        subjectString.replace(phoneRegex, "($1) $2-$3");
} else {
    // Invalid phone number
}</pre>
<h3>Discussion</h3>
<pre>^        # Assert position at the beginning of the string.
\(       # Match a literal "("
  ?      #   between zero and one time.
(        # Capture the enclosed match to backreference 1:
  [0-9]  #   Match a digit
    {3}  #     exactly three times.
)        # End capturing group 1.
\)       # Match a literal ")"
  ?      #   between zero and one time.
[-. ]    # Match one hyphen, dot, or space
  ?      #   between zero and one time.
=E2=80=A6       # [Match the remaining digits and separator.]
$        # Assert position at the end of the string.</pre>
<h3>Variations</h3>
<h4>Eliminate invalid phone numbers</h4>
<pre>^\(?([2-9][0-8][0-9])\)?[-. ]?([2-9][0-9]{2})[-. ]?([0-9]{4})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Find phone numbers in documents</h4>
<pre>\(?\b([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Allow a leading =E2=80=9C1=E2=80=9D</h4>
<pre>^(?:\+?1[-. ]?)?\(?([0-9]{3})\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$</pre=
>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Allow seven-digit phone numbers</h4>
<pre>^(?:\(?([0-9]{3})\)?[-. ]?)?([0-9]{3})[-. ]?([0-9]{4})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.3. Validate International Phone Numbers</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^\+(?:[0-9] ?){6,14}[0-9]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>JavaScript example</h4>
<pre>function validate(phone) {
    var regex =3D /^\+(?:[0-9] ?){6,14}[0-9]$/;

    if (regex.test(phone)) {
        // Valid international phone number
    } else {
        // Invalid international phone number
    }
}</pre>
<h3>Discussion</h3>
<pre>^         # Assert position at the beginning of the string.
\+        # Match a literal "+" character.
(?:       # Group but don't capture:
  [0-9]   #   Match a digit.
  \x20    #   Match a space character
    ?     #     between zero and one time.
)         # End the noncapturing group.
  {6,14}  #   Repeat the group between 6 and 14 times.
[0-9]     # Match a digit.
$         # Assert position at the end of the string.</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Validate international phone numbers in EPP format</h4>
<pre>^\+[0-9]{1,3}\.[0-9]{4,14}(?:x.+)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.4. Validate Traditional Date Formats</h2>
<h3>Solution</h3>
<pre>^[0-3]?[0-9]/[0-3]?[0-9]/(?:[0-9]{2})?[0-9]{2}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[0-3][0-9]/[0-3][0-9]/(?:[0-9][0-9])?[0-9][0-9]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(1[0-2]|0?[1-9])/(3[01]|[12][0-9]|0?[1-9])/(?:[0-9]{2})?[0-9]{2}$</pr=
e>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(1[0-2]|0[1-9])/(3[01]|[12][0-9]|0[1-9])/[0-9]{4}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3[01]|[12][0-9]|0?[1-9])/(1[0-2]|0?[1-9])/(?:[0-9]{2})?[0-9]{2}$</pr=
e>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3[01]|[12][0-9]|0[1-9])/(1[0-2]|0[1-9])/[0-9]{4}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(1[0-2]|0?[1-9])/(3[01]|[12][0-9]|0?[1-9])|(3[01]|[12][0-9]|0?[1-9=
])/(1[0-2]|0?[1-9]))/(?:[0-9]{2})?[0-9]{2}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:
  # m/d or mm/dd
  (1[0-2]|0?[1-9])/(3[01]|[12][0-9]|0?[1-9])
|
  # d/m or dd/mm
  (3[01]|[12][0-9]|0?[1-9])/(1[0-2]|0?[1-9])
)
# /yy or /yyyy
/(?:[0-9]{2})?[0-9]{2}$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(1[0-2]|0[1-9])/(3[01]|[12][0-9]|0[1-9])|(3[01]|[12][0-9]|0[1-9])/=
(1[0-2]|0[1-9]))/[0-9]{4}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:
  # mm/dd
  (1[0-2]|0[1-9])/(3[01]|[12][0-9]|0[1-9])
|
  # dd/mm
  (3[01]|[12][0-9]|0[1-9])/(1[0-2]|0[1-9])
)
# /yyyy
/[0-9]{4}$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>\b(1[0-2]|0[1-9])/(3[01]|[12][0-9]|0[1-9])/[0-9]{4}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.5. Validate Traditional Date Formats, Excluding Invalid Dates</h2>
<h3>Solution</h3>
<h4>C#</h4>
<pre>^(?&lt;month&gt;[0-3]?[0-9])/(?&lt;day&gt;[0-3]?[0-9])/(?&lt;year&gt;(=
?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10</p>
<pre>DateTime foundDate;
Match matchResult =3D Regex.Match(SubjectString,
    "^(?&lt;month&gt;[0-3]?[0-9])/(?&lt;day&gt;[0-3]?[0-9])/" +
    "(?&lt;year&gt;(?:[0-9]{2})?[0-9]{2})$");
if (matchResult.Success) {
    int year =3D int.Parse(matchResult.Groups["year"].Value);
    if (year &lt; 50) year +=3D 2000;
    else if (year &lt; 100) year +=3D 1900;
    try {
        foundDate =3D new DateTime(year,
            int.Parse(matchResult.Groups["month"].Value),
            int.Parse(matchResult.Groups["day"].Value));
    } catch {
        // Invalid date
    }
}</pre>
<pre>^(?&lt;day&gt;[0-3]?[0-9])/(?&lt;month&gt;[0-3]?[0-9])/(?&lt;year&gt;(=
?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10</p>
<pre>DateTime foundDate;
Match matchResult =3D Regex.Match(SubjectString,
    "^(?&lt;day&gt;[0-3]?[0-9])/(?&lt;month&gt;[0-3]?[0-9])/" +
    "(?&lt;year&gt;(?:[0-9]{2})?[0-9]{2})$");
if (matchResult.Success) {
    int year =3D int.Parse(matchResult.Groups["year"].Value);
    if (year &lt; 50) year +=3D 2000;
    else if (year &lt; 100) year +=3D 1900;
    try {
        foundDate =3D new DateTime(year,
            int.Parse(matchResult.Groups["month"].Value),
            int.Parse(matchResult.Groups["day"].Value));
    } catch {
        // Invalid date
    }
}</pre>
<h4>Perl</h4>
<pre>^([0-3]?[0-9])/([0-3]?[0-9])/((?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>@daysinmonth =3D (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
$validdate =3D 0;
if ($subject =3D~ m!^([0-3]?[0-9])/([0-3]?[0-9])/((?:[0-9]{2})?[0-9]{2})$!)=
=20
{
    $month =3D $1;
    $day =3D $2;
    $year =3D $3;
    $year +=3D 2000 if $year &lt; 50;
    $year +=3D 1900 if $year &lt; 100;
    if ($month =3D=3D 2 &amp;&amp; $year % 4 =3D=3D 0 &amp;&amp; ($year % 1=
00 !=3D 0 ||
                                          $year % 400 =3D=3D 0)) {
    	$validdate =3D 1 if $day &gt;=3D 1 &amp;&amp; $day &lt;=3D 29;
    } elsif ($month &gt;=3D 1 &amp;&amp; $month &lt;=3D 12) {
        $validdate =3D 1 if $day &gt;=3D 1 &amp;&amp; $day &lt;=3D $daysinm=
onth[$month-1];
    }
}</pre>
<pre>@daysinmonth =3D (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
$validdate =3D 0;
if ($subject =3D~ m!^([0-3]?[0-9])/([0-3]?[0-9])/((?:[0-9]{2})?[0-9]{2})$!)=
=20
{
    $day =3D $1;
    $month =3D $2;
    $year =3D $3;
    $year +=3D 2000 if $year &lt; 50;
    $year +=3D 1900 if $year &lt; 100;
    if ($month =3D=3D 2 &amp;&amp; $year % 4 =3D=3D 0 &amp;&amp; ($year % 1=
00 !=3D 0 ||
                                          $year % 400 =3D=3D 0)) {
    	$validdate =3D 1 if $day &gt;=3D 1 &amp;&amp; $day &lt;=3D 29;
    } elsif ($month &gt;=3D 1 &amp;&amp; $month &lt;=3D 12) {
        $validdate =3D 1 if $day &gt;=3D 1 &amp;&amp; $day &lt;=3D $daysinm=
onth[$month-1];
    }
}</pre>
<h4>Pure regular expression</h4>
<pre>^(?:
  # February (29 days every year)
  (?&lt;month&gt;0?2)/(?&lt;day&gt;[12][0-9]|0?[1-9])
|
  # 30-day months
  (?&lt;month&gt;0?[469]|11)/(?&lt;day&gt;30|[12][0-9]|0?[1-9])
|
  # 31-day months
  (?&lt;month&gt;0?[13578]|1[02])/(?&lt;day&gt;3[01]|[12][0-9]|0?[1-9])
)
# Year
/(?&lt;year&gt;(?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Perl 5.10, Ruby 1.9</p>
<pre>^(?:
  # February (29 days every year)
  (0?2)/([12][0-9]|0?[1-9])
|
  # 30-day months
  (0?[469]|11)/(30|[12][0-9]|0?[1-9])
|
  # 31-day months
  (0?[13578]|1[02])/(3[01]|[12][0-9]|0?[1-9])
)
# Year
/((?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(0?2)/([12][0-9]|0?[1-9])|(0?[469]|11)/(30|[12][0-9]|0?[1-9])|(0?[=
13578]|1[02])/(3[01]|[12][0-9]|0?[1-9]))/((?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:
  # February (29 days every year)
  (?&lt;day&gt;[12][0-9]|0?[1-9])/(?&lt;month&gt;0?2)
|
  # 30-day months
  (?&lt;day&gt;30|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[469]|11)
|
  # 31-day months
  (?&lt;day&gt;3[01]|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[13578]|1[02])
)
# Year
/(?&lt;year&gt;(?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Perl 5.10, Ruby 1.9</p>
<pre>^(?:
  # February (29 days every year)
  ([12][0-9]|0?[1-9])/(0?2)
|
  # 30-day months
  (30|[12][0-9]|0?[1-9])/([469]|11)
|
  # 31-day months
  (3[01]|[12][0-9]|0?[1-9])/(0?[13578]|1[02])
)
# Year
/((?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:([12][0-9]|0?[1-9])/(0?2)|(30|[12][0-9]|0?[1-9])/([469]|11)|(3[01]=
|[12][0-9]|0?[1-9])/(0?[13578]|1[02]))/((?:[0-9]{2})?[0-9]{2})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre># 2 May 2007 till 29 August 2008
^(?:
  # 2 May 2007 till 31 December 2007
  (?:
    # 2 May till 31 May
    (?&lt;day&gt;3[01]|[12][0-9]|0?[2-9])/(?&lt;month&gt;0?5)/(?&lt;year&gt=
;2007)
  |
    # 1 June till 31 December
    (?:
      # 30-day months
      (?&lt;day&gt;30|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[69]|11)
    |
      # 31-day months
      (?&lt;day&gt;3[01]|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[78]|1[02])
    )
    /(?&lt;year&gt;2007)
  )
|
  # 1 January 2008 till 29 August 2008
  (?:
    # 1 August till 29 August
    (?&lt;day&gt;[12][0-9]|0?[1-9])/(?&lt;month&gt;0?8)/(?&lt;year&gt;2008)
  |
    # 1 Janary till 30 June
    (?:
      # February
      (?&lt;day&gt;[12][0-9]|0?[1-9])/(?&lt;month&gt;0?2)
    |
      # 30-day months
      (?&lt;day&gt;30|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[46])
    |
      # 31-day months
      (?&lt;day&gt;3[01]|[12][0-9]|0?[1-9])/(?&lt;month&gt;0?[1357])
    )
    /(?&lt;year&gt;2008)
  )
)$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Perl 5.10, Ruby 1.9</p>
<h2>4.6. Validate Traditional Time Formats</h2>
<h3>Solution</h3>
<pre>^(1[0-2]|0?[1-9]):([0-5]?[0-9])( ?[AP]M)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(1[0-2]|0?[1-9]):([0-5]?[0-9]):([0-5]?[0-9])( ?[AP]M)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(2[0-3]|[01]?[0-9]):([0-5]?[0-9]):([0-5]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>\b(2[0-3]|[01]?[0-9]):([0-5]?[0-9])\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>(?&lt;![:\w])(2[0-3]|[01]?[0-9]):([0-5]?[0-9])(?![:\w])</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby 1.9</p>
<h2>4.7. Validate ISO 8601 Dates and Times</h2>
<h3>Solution</h3>
<h4>Dates</h4>
<pre>^([0-9]{4})-(1[0-2]|0[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;1[0-2]|0[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?P&lt;year&gt;[0-9]{4})-(?P&lt;month&gt;1[0-2]|0[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: PCRE,
          Python</p>
<pre>^([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-?(?&lt;month&gt;1[0-2]|0[1-9])-?(?&lt;day&gt;=
3[01]|0[1-9]|[12][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^([0-9]{4})(-?)(1[0-2]|0[1-9])\2(3[01]|0[1-9]|[12][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})(?&lt;hyphen&gt;-?)(?&lt;month&gt;1[0-2]|0[1-9=
])\k&lt;hyphen&gt;(?&lt;day&gt;3[01]|0[1-9]|[12][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?P&lt;year&gt;[0-9]{4})(?P&lt;hyphen&gt;-?)(?P&lt;month&gt;1[0-2]|0[=
1-9])(?P=3Dhyphen)(?&lt;day&gt;3[01]|0[1-9]|[12][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^([0-9]{4})-?(36[0-6]|3[0-5][0-9]|[12][0-9]{2}|0[1-9][0-9]|00[1-9])$</=
pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-?(?&lt;day&gt;36[0-6]|3[0-5][0-9]|[12][0-9]{2=
}|0[1-9][0-9]|00[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<h4>Weeks</h4>
<pre>^([0-9]{4})-?W(5[0-3]|[1-4][0-9]|0[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-?W(?&lt;week&gt;5[0-3]|[1-4][0-9]|0[1-9])$</p=
re>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^([0-9]{4})-?W(5[0-3]|[1-4][0-9]|0[1-9])-?([1-7])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-?W(?&lt;week&gt;5[0-3]|[1-4][0-9]|0[1-9])-?(?=
&lt;day&gt;[1-7])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<h4>Times</h4>
<pre>^(2[0-3]|[01][0-9]):?([0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;hour&gt;2[0-3]|[01][0-9]):?(?&lt;minute&gt;[0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;hour&gt;2[0-3]|[01][0-9]):?(?&lt;minute&gt;[0-5][0-9]):?(?&lt;s=
econd&gt;[0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-5][0-9]))?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(2[0-3]|[01][0-9]):?([0-5][0-9]):?([0-5][0-9])(Z|[+-](?:2[0-3]|[01][0=
-9])(?::?(?:[0-5][0-9]))?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;hour&gt;2[0-3]|[01][0-9]):?(?&lt;minute&gt;[0-5][0-9]):?(?&lt;s=
econd&gt;[0-5][0-9])(?&lt;timezone&gt;Z|[+-](?:2[0-3]|[01][0-9])(?::?(?:[0-=
5][0-9]))?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<h4>Date and time</h4>
<pre>^([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9]) (2[0-3]|[01][0-=
9]):?([0-5][0-9]):?([0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;[0-9]{4})-?(?&lt;month&gt;1[0-2]|0[1-9])-?(?&lt;day&gt;=
3[01]|0[1-9]|[12][0-9]) (?&lt;hour&gt;2[0-3]|[01][0-9]):?(?&lt;minute&gt;[0=
-5][0-9]):?(?&lt;second&gt;[0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^([0-9]{4})(-)?(1[0-2]|0[1-9])(?(2)-)(3[01]|0[1-9]|[12][0-9]) (2[0-3]|=
[01][0-9])(?(2):)([0-5][0-9])(?(2):)([0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE, Perl, Python</p>
<pre>^(?&lt;year&gt;[0-9]{4})(?&lt;hyphen&gt;-)?(?&lt;month&gt;1[0-2]|0[1-9=
])(?(hyphen)-)(?&lt;day&gt;3[01]|0[1-9]|[12][0-9]) (?&lt;hour&gt;2[0-3]|[01=
][0-9])(?(hyphen):)(?&lt;minute&gt;[0-5][0-9])(?(hyphen):)(?&lt;second&gt;[=
0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE 7, Perl 5.10</p>
<pre>^(?P&lt;year&gt;[0-9]{4})(?P&lt;hyphen&gt;-)?(?P&lt;month&gt;1[0-2]|0[=
1-9])(?(hyphen)-)(?P&lt;day&gt;3[01]|0[1-9]|[12][0-9]) (?P&lt;hour&gt;2[0-3=
]|[01][0-9])(?(hyphen):)(?P&lt;minute&gt;[0-5][0-9])(?(hyphen):)(?P&lt;seco=
nd&gt;[0-5][0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: PCRE,
          Perl 5.10, Python</p>
<pre>^(?:([0-9]{4})-?(1[0-2]|0[1-9])-?(3[01]|0[1-9]|[12][0-9]) (2[0-3]|[01]=
[0-9]):?([0-5][0-9]):?([0-5][0-9])|([0-9]{4})(1[0-2]|0[1-9])(3[01]|0[1-9]|[=
12][0-9]) (2[0-3]|[01][0-9])([0-5][0-9])([0-5][0-9]))$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>XML Schema dates and times</h4>
<pre>^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])=
(Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;-?(?:[1-9][0-9]*)?[0-9]{4})-(?&lt;month&gt;1[0-2]|0[1-9=
])-(?&lt;day&gt;3[01]|0[1-9]|[12][0-9])(?&lt;timezone&gt;Z|[+-](?:2[0-3]|[0=
1][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.[0-9]+)?(Z|[+-](?:2[0-=
3]|[01][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;hour&gt;2[0-3]|[01][0-9]):(?&lt;minute&gt;[0-5][0-9]):(?&lt;sec=
ond&gt;[0-5][0-9])(?&lt;frac&gt;\.[0-9]+)?(?&lt;timezone&gt;Z|[+-](?:2[0-3]=
|[01][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])=
T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(\.[0-9]+)?(Z|[+-](?:2[0-3]|[0=
1][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?&lt;year&gt;-?(?:[1-9][0-9]*)?[0-9]{4})-(?&lt;month&gt;1[0-2]|0[1-9=
])-(?&lt;day&gt;3[01]|0[1-9]|[12][0-9])T(?&lt;hour&gt;2[0-3]|[01][0-9]):(?&=
lt;minute&gt;[0-5][0-9]):(?&lt;second&gt;[0-5][0-9])(?&lt;ms&gt;\.[0-9]+)?(=
?&lt;timezone&gt;Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<h2>4.8. Limit Input to Alphanumeric Characters</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^[A-Z0-9]+$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Ruby example</h4>
<pre>if subject =3D~ /^[A-Z0-9]+$/i
    puts "Subject is alphanumeric"
else
    puts "Subject is not alphanumeric"
end</pre>
<h3>Discussion</h3>
<pre>^         # Assert position at the beginning of the string.
[A-Z0-9]  # Match a character from A to Z or from 0 to 9
  +       #   between one and unlimited times.
$         # Assert position at the end of the string.</pre>
<p>Regex options: Case
        insensitive, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Limit input to ASCII characters</h4>
<pre>^[\x00-\x7F]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Limit input to ASCII noncontrol characters and line
        breaks</h4>
<pre>^[\n\r\x20-\x7E]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Limit input to shared ISO-8859-1 and Windows-1252
        characters</h4>
<pre>^[\x00-\x7F\xA0-\xFF]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Limit input to alphanumeric characters in any language</h4>
<pre>^[\p{L}\p{M}\p{Nd}]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<pre>^[^\W_]+$</pre>
<p>Regex options: Unicode<br>
Regex flavors: Python</p>
<h2>4.9. Limit the Length of Text</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^[A-Z]{1,10}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Perl example</h4>
<pre>if ($ARGV[0] =3D~ /^[A-Z]{1,10}$/) {
    print "Input is valid\n";
} else {
    print "Input is invalid\n";
}</pre>
<h3>Discussion</h3>
<pre>^         # Assert position at the beginning of the string.
[A-Z]     # Match one letter from A to Z
  {1,10}  #   between 1 and 10 times.
$         # Assert position at the end of the string.</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Limit the length of an arbitrary pattern</h4>
<pre>^(?=3D.{1,10}$).*</pre>
<p>Regex options: Dot
          matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?=3D[\S\s]{1,10}$)[\S\s]*</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Limit the number of nonwhitespace characters</h4>
<pre>^\s*(?:\S\s*){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[\p{Z}\s]*(?:[^\p{Z}\s][\p{Z}\s]*){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<h4>Limit the number of words</h4>
<pre>^\W*(?:\w+\b\W*){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[^\p{L}\p{M}\p{Nd}\p{Pc}]*(?:[\p{L}\p{M}\p{Nd}\p{Pc}]+\b[^\p{L}\p{M}\=
p{Nd}\p{Pc}]*){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, Perl</p>
<pre>^[^\p{L}\p{M}\p{Nd}\p{Pc}]*(?:[\p{L}\p{M}\p{Nd}\p{Pc}]+(?:[^\p{L}\p{M}=
\p{Nd}\p{Pc}]+|$)){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<pre>^\s*(?:\S+(?:\s+|$)){10,100}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, Perl, PCRE, Python, Ruby</p>
<h2>4.10. Limit the Number of Lines in Text</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>\A(?&gt;[^\r\n]*(?&gt;\r\n?|\n)){0,4}[^\r\n]*\z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby</p>
<pre>\A(?:[^\r\n]*(?:\r\n?|\n)){0,4}[^\r\n]*\Z</pre>
<p>Regex options: None<br>
</p><pre>^(?:[^\r\n]*(?:\r\n?|\n)){0,4}[^\r\n]*$</pre>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
</p><h4>PHP (PCRE) example</h4>
<pre>if (preg_match('/\A(?&gt;[^\r\n]*(?&gt;\r\n?|\n)){0,4}[^\r\n]*\z/',=20
               $_POST['subject'])) {
    print 'Subject contains five or fewer lines';
} else {
    print 'Subject contains more than five lines';
}</pre>
<h3>Discussion</h3>
<pre>\A          # Assert position at the beginning of the string.
(?&gt;         # Group but don't capture or keep backtracking positions:
  [^\r\n]*  #   Match zero or more characters except CR and LF.
  (?&gt;       #   Group but don't capture or keep backtracking positions:
    \r\n?   #     Match a CR, with an optional following LF (CRLF).
   |        #    Or:
    \n      #     Match a standalone LF character.
  )         #   End the noncapturing, atomic group.
){0,4}      # End group; repeat between zero and four times.
[^\r\n]*    # Match zero or more characters except CR and LF.
\z          # Assert position at the end of the string.</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Ruby</p>
<h3>Variations</h3>
<h4>Working with esoteric line separators</h4>
<pre>\A(?&gt;\V*\R){0,4}\V*\z</pre>
<p>Regex options: None<br>
</p><pre>\A(?&gt;[^\n-\r\x85\x{2028}\x{2029}]*(?&gt;\r\n?|[\n-\f\x85\x{2028=
}\x{2029}])){0,4}[^\n-\r\x85\x{2028}\x{2029}]*\z</pre>
<p>Regex options: None<br>
Regex flavors: Java
          7, PCRE, Perl</p>
<pre>\A(?&gt;[^\n-\r\u0085\u2028\u2029]*(?&gt;\r\n?|[\n-\f\u0085\u2028\u202=
9])){0,4}[^\n-\r\u0085\u2028\u2029]*\z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, Ruby 1.9</p>
<pre>\A(?&gt;[^\n-\r\x85\u2028\u2029]*(?&gt;\r\n?|[\n-\f\x85\u2028\u2029]))=
{0,4}[^\n-\r\x85\u2028\u2029]*\z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java</p>
<pre>\A(?:[^\n-\r\x85\u2028\u2029]*(?:\r\n?|[\n-\f\x85\u2028\u2029])){0,4}[=
^\n-\r\x85\u2028\u2029]*\Z</pre>
<p>Regex options: None<br>
</p><pre>^(?:[^\n-\r\x85\u2028\u2029]*(?:\r\n?|[\n-\f\x85\u2028\u2029])){0,=
4}[^\n-\r\x85\u2028\u2029]*$</pre>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
</p><h2>4.11. Validate Affirmative Responses</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^(?:1|t(?:rue)?|y(?:es)?|ok(?:ay)?)$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>JavaScript example</h4>
<pre>var yes =3D /^(?:1|t(?:rue)?|y(?:es)?|ok(?:ay)?)$/i;

if (yes.test(subject)) {
    alert("Yes");
} else {
    alert("No");
}</pre>
<h3>Discussion</h3>
<pre>^            # Assert position at the beginning of the string.
(?:          # Group but don't capture:
  1          #   Match "1".
 |           #  Or:
  t(?:rue)?  #   Match "t", optionally followed by "rue".
 |           #  Or:
  y(?:es)?   #   Match "y", optionally followed by "es".
 |           #  Or:
  ok(?:ay)?  #   Match "ok", optionally followed by "ay".
)            # End the noncapturing group.
$            # Assert position at the end of the string.</pre>
<p>Regex options: Case
        insensitive, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>4.12. Validate Social Security Numbers</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^(?!000|666)[0-8][0-9]{2}-(?!00)[0-9]{2}-(?!0000)[0-9]{4}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Python example</h4>
<pre>if re.match(r"^(?!000|666)[0-8][0-9]{2}-(?!00)[0-9]{2}-(?!0000)[0-9]{4=
}$", sys.argv[1]):
    print "SSN is valid"
else:
    print "SSN is invalid"</pre>
<h3>Discussion</h3>
<pre>^            # Assert position at the beginning of the string.
(?!000|666)  # Assert that neither "000" nor "666" can be matched here.
[0-8]        # Match a digit between 0 and 8.
[0-9]{2}     # Match a digit, exactly two times.
-            # Match a literal "-".
(?!00)       # Assert that "00" cannot be matched here.
[0-9]{2}     # Match a digit, exactly two times.
-            # Match a literal "-".
(?!0000)     # Assert that "0000" cannot be matched here.
[0-9]{4}     # Match a digit, exactly four times.
$            # Assert position at the end of the string.</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Find Social Security numbers in documents</h4>
<pre>\b(?!000|666)[0-8][0-9]{2}-(?!00)[0-9]{2}-(?!0000)[0-9]{4}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.13. Validate ISBNs</h2>
<h3>Solution</h3>
<h4>Regular expressions</h4>
<pre>^(?:ISBN(?:-10)?:? )?(?=3D[0-9X]{10}$|(?=3D(?:[0-9]+[- ]){3})[- 0-9X]{=
13}$)[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^
(?:ISBN(?:-10)?:?\ )?     # Optional ISBN/ISBN-10 identifier.
(?=3D                       # Basic format pre-checks (lookahead):
  [0-9X]{10}$             #   Require 10 digits/Xs (no separators).
 |                        #  Or:
  (?=3D(?:[0-9]+[-\ ]){3})  #   Require 3 separators
  [-\ 0-9X]{13}$          #     out of 13 characters total.
)                         # End format pre-checks.
[0-9]{1,5}[-\ ]?          # 1-5 digit group identifier.
[0-9]+[-\ ]?[0-9]+[-\ ]?  # Publisher and title identifiers.
[0-9X]                    # Check digit.
$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:ISBN(?:-13)?:? )?(?=3D[0-9]{13}$|(?=3D(?:[0-9]+[- ]){4})[- 0-9]{17=
}$)97[89][- ]?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^
(?:ISBN(?:-13)?:?\ )?     # Optional ISBN/ISBN-13 identifier.
(?=3D                       # Basic format pre-checks (lookahead):
  [0-9]{13}$              #   Require 13 digits (no separators).
 |                        #  Or:
  (?=3D(?:[0-9]+[-\ ]){4})  #   Require 4 separators
  [-\ 0-9]{17}$           #     out of 17 characters total.
)                         # End format pre-checks.
97[89][-\ ]?              # ISBN-13 prefix.
[0-9]{1,5}[-\ ]?          # 1-5 digit group identifier.
[0-9]+[-\ ]?[0-9]+[-\ ]?  # Publisher and title identifiers.
[0-9]                     # Check digit.
$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:ISBN(?:-1[03])?:? )?(?=3D[0-9X]{10}$|(?=3D(?:[0-9]+[- ]){3})[- 0-9=
X]{13}$|97[89][0-9]{10}$|(?=3D(?:[0-9]+[- ]){4})[- 0-9]{17}$)(?:97[89][- ]?=
)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^
(?:ISBN(?:-1[03])?:?\ )?  # Optional ISBN/ISBN-10/ISBN-13 identifier.
(?=3D                       # Basic format pre-checks (lookahead):
  [0-9X]{10}$             #   Require 10 digits/Xs (no separators).
 |                        #  Or:
  (?=3D(?:[0-9]+[-\ ]){3})  #   Require 3 separators
  [-\ 0-9X]{13}$          #     out of 13 characters total.
 |                        #  Or:
  97[89][0-9]{10}$        #   978/979 plus 10 digits (13 total).
 |                        #  Or:
  (?=3D(?:[0-9]+[-\ ]){4})  #   Require 4 separators
  [-\ 0-9]{17}$           #     out of 17 characters total.
)                         # End format pre-checks.
(?:97[89][-\ ]?)?         # Optional ISBN-13 prefix.
[0-9]{1,5}[-\ ]?          # 1-5 digit group identifier.
[0-9]+[-\ ]?[0-9]+[-\ ]?  # Publisher and title identifiers.
[0-9X]                    # Check digit.
$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>JavaScript example, with checksum validation</h4>
<pre>var subject =3D document.getElementById("isbn").value;

// Checks for ISBN-10 or ISBN-13 format
var regex =3D /^(?:ISBN(?:-1[03])?:? )?(?=3D[0-9X]{10}$|(?=3D(?:[0-9]+[- ])=
{3})[- 0-9X]{13}$|97[89][0-9]{10}$|(?=3D(?:[0-9]+[- ]){4})[- 0-9]{17}$)(?:9=
7[89][- ]?)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]$/;

if (regex.test(subject)) {
    // Remove non ISBN digits, then split into an array
    var chars =3D subject.replace(/[- ]|^ISBN(?:-1[03])?:?/g, "").split("")=
;
    // Remove the final ISBN digit from `chars`, and assign it to `last`
    var last =3D chars.pop();
    var sum =3D 0;
    var check, i;

    if (chars.length =3D=3D 9) {
        // Compute the ISBN-10 check digit
        chars.reverse();
        for (i =3D 0; i &lt; chars.length; i++) {
            sum +=3D (i + 2) * parseInt(chars[i], 10);
        }
        check =3D 11 - (sum % 11);
        if (check =3D=3D 10) {
            check =3D "X";
        } else if (check =3D=3D 11) {
            check =3D "0";
        }
    } else {
        // Compute the ISBN-13 check digit
        for (i =3D 0; i &lt; chars.length; i++) {
            sum +=3D (i % 2 * 2 + 1) * parseInt(chars[i], 10);
        }
        check =3D 10 - (sum % 10);
        if (check =3D=3D 10) {
            check =3D "0";
        }
    }

    if (check =3D=3D last) {
        alert("Valid ISBN");
    } else {
        alert("Invalid ISBN check digit");
    }
} else {
    alert("Invalid ISBN");
}</pre>
<h4>Python example, with checksum validation</h4>
<pre>import re
import sys

subject =3D sys.argv[1]

# Checks for ISBN-10 or ISBN-13 format
regex =3D re.compile("^(?:ISBN(?:-1[03])?:? )?(?=3D[0-9X]{10}$|(?=3D(?:[0-9=
]+[- ]){3})[- 0-9X]{13}$|97[89][0-9]{10}$|(?=3D(?:[0-9]+[- ]){4})[- 0-9]{17=
}$)(?:97[89][- ]?)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]$")

if regex.search(subject):
    # Remove non ISBN digits, then split into a list
    chars =3D list(re.sub("[- ]|^ISBN(?:-1[03])?:?", "", subject))
    # Remove the final ISBN digit from `chars`, and assign it to `last`
    last =3D chars.pop()

    if len(chars) =3D=3D 9:
        # Compute the ISBN-10 check digit
        val =3D sum((x + 2) * int(y) for x,y in enumerate(reversed(chars)))
        check =3D 11 - (val % 11)
        if check =3D=3D 10:
            check =3D "X"
        elif check =3D=3D 11:
            check =3D "0"
    else:
        # Compute the ISBN-13 check digit
        val =3D sum((x % 2 * 2 + 1) * int(y) for x,y in enumerate(chars))
        check =3D 10 - (val % 10)
        if check =3D=3D 10:
            check =3D "0"

    if (str(check) =3D=3D last):
        print("Valid ISBN")
    else:
        print("Invalid ISBN check digit")
else:
    print("Invalid ISBN")</pre>
<h3>Discussion</h3>
<h4>ISBN-10 checksum</h4>
<pre>Step 1:
sum =3D 10=C3=970 + 9=C3=975 + 8=C3=979 + 7=C3=976 + 6=C3=975 + 5=C3=972 + =
4=C3=970 + 3=C3=976 + 2=C3=978
    =3D    0 +  45 +  72 +  42 +  30 +  10 +   0 +  18 +  16
    =3D 233
Step 2:
    233 =C3=B7 11 =3D 21, remainder 2
Step 3:
    11 =E2=88=92 2 =3D 9
Step 4:
    9 [no substitution required]</pre>
<h4>ISBN-13 checksum</h4>
<pre>Step 1:
sum =3D 1=C3=979 + 3=C3=977 + 1=C3=978 + 3=C3=970 + 1=C3=975 + 3=C3=979 + 1=
=C3=976 + 3=C3=975 + 1=C3=972 + 3=C3=970 + 1=C3=976 + 3=C3=978
    =3D   9 +  21 +   8 +   0 +   5 +  27 +   6 +  15 +   2 +   0 +   6 +  =
24
    =3D 123
Step 2:
    123 =C3=B7 10 =3D 12, remainder 3
Step 3:
    10 =E2=88=92 3 =3D 7
Step 4:
    7 [no substitution required]</pre>
<h3>Variations</h3>
<h4>Find ISBNs in documents</h4>
<pre>\bISBN(?:-1[03])?:? (?=3D[0-9X]{10}$|(?=3D(?:[0-9]+[- ]){3})[- 0-9X]{1=
3}$|97[89][0-9]{10}$|(?=3D(?:[0-9]+[- ]){4})[- 0-9]{17}$)(?:97[89][- ]?)?[0=
-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Eliminate incorrect ISBN identifiers</h4>
<pre>^
(?:ISBN(-1(?:(0)|3))?:?\ )?
(?(1)
  (?(2)
    # ISBN-10
    (?=3D[0-9X]{10}$|(?=3D(?:[0-9]+[- ]){3})[- 0-9X]{13}$)
    [0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]
   |
    # ISBN-13
    (?=3D[0-9]{13}$|(?=3D(?:[0-9]+[- ]){4})[- 0-9]{17}$)
    97[89][- ]?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9]
  )
 |
  # No explicit identifier; allow ISBN-10 or ISBN-13
  (?=3D[0-9X]{10}$|(?=3D(?:[0-9]+[- ]){3})[- 0-9X]{13}$|97[89][0-9]{10}$|
    (?=3D(?:[0-9]+[- ]){4})[- 0-9]{17}$)
  (?:97[89][- ]?)?[0-9]{1,5}[- ]?[0-9]+[- ]?[0-9]+[- ]?[0-9X]
)
$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          PCRE, Perl, Python</p>
<h2>4.14. Validate ZIP Codes</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^[0-9]{5}(?:-[0-9]{4})?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>VB.NET example</h4>
<pre>If Regex.IsMatch(subjectString, "^[0-9]{5}(?:-[0-9]{4})?$") Then
    Console.WriteLine("Valid ZIP code")
Else
    Console.WriteLine("Invalid ZIP code")
End If</pre>
<h3>Discussion</h3>
<pre>^           # Assert position at the beginning of the string.
[0-9]{5}    # Match a digit, exactly five times.
(?:         # Group but don't capture:
  -         #   Match a literal "-".
  [0-9]{4}  #   Match a digit, exactly four times.
)           # End the noncapturing group.
  ?         #   Make the group optional.
$           # Assert position at the end of the string.</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>4.15. Validate Canadian Postal Codes</h2>
<h3>Solution</h3>
<pre>^(?!.*[DFIOQU])[A-VXY][0-9][A-Z] ?[0-9][A-Z][0-9]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.16. Validate U.K. Postcodes</h2>
<h3>Solution</h3>
<pre>^[A-Z]{1,2}[0-9R][0-9A-Z]? [0-9][ABD-HJLNP-UW-Z]{2}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>^(?:(?:[A-PR-UWYZ][0-9]{1,2}|[A-PR-UWYZ][A-HK-Y][0-9]{1,2}|[A-PR-UWYZ]=
[0-9][A-HJKSTUW]|[A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRV-Y]) [0-9][ABD-HJLNP-UW-=
Z]{2}|GIR 0AA)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>4.17. Find Addresses with Post Office Boxes</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^(?:Post(?:al)? (?:Office )?|P[. ]?O\.? )?Box\b</pre>
<p>Regex options: Case
          insensitive, ^ and $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>C# example</h4>
<pre>Regex regexObj =3D new Regex(
    @"^(?:Post(?:al)? (?:Office )?|P[. ]?O\.? )?Box\b",
    RegexOptions.IgnoreCase | RegexOptions.Multiline
);
if (regexObj.IsMatch(subjectString) {
    Console.WriteLine("The value does not appear to be a street address");
} else {
    Console.WriteLine("Good to go");
}</pre>
<h3>Discussion</h3>
<pre>^                # Assert position at the beginning of a line.
(?:              # Group but don't capture:
  Post(?:al)?\   #   Match "Post " or "Postal ".
  (?:Office\ )?  #   Optionally match "Office ".
 |               #  Or:
  P[.\ ]?        #   Match "P" and an optional period or space character.
  O\.?\          #   Match "O", an optional period, and a space character.
)?               # Make the group optional.
Box              # Match "Box".
\b               # Assert position at a word boundary.</pre>
<p>Regex options: Case
        insensitive, ^ and $ match at line breaks, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>4.18. Reformat Names From =E2=80=9CFirstName LastName=E2=80=9D to =E2=
=80=9CLastName,
    FirstName=E2=80=9D</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^(.+?) ([^\s,]+)(,? (?:[JS]r\.?|III?|IV))?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>$2, $1$3</pre>
<pre>\2, \1\3</pre>
<h4>JavaScript example</h4>
<pre>function formatName(name) {
    return name.replace(/^(.+?) ([^\s,]+)(,? (?:[JS]r\.?|III?|IV))?$/i,
                        "$2, $1$3");
}</pre>
<h3>Discussion</h3>
<pre>^              # Assert position at the beginning of the string.
(              # Capture the enclosed match to backreference 1:
  .+?          #   Match one or more characters, as few times as possible.
)              # End the capturing group.
\              # Match a literal space character.
(              # Capture the enclosed match to backreference 2:
  [^\s,]+      #   Match one or more non-whitespace/comma characters.
)              # End the capturing group.
(              # Capture the enclosed match to backreference 3:
  ,?\          #   Match ", " or " ".
  (?:          #   Group but don't capture:
    [JS]r\.?   #     Match "Jr", "Jr.", "Sr", or "Sr.".
   |           #    Or:
    III?       #     Match "II" or "III".
   |           #    Or:
    IV         #     Match "IV".
  )            #   End the noncapturing group.
)?             # Make the group optional.
$              # Assert position at the end of the string.</pre>
<p>Regex options: Case
        insensitive, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>List surname particles at the beginning of the name</h4>
<pre>^(.+?) ((?:(?:d[eu]|l[ae]|Ste?\.?|v[ao]n) )*[^\s,]+)(,? (?:[JS]r\.?|II=
I?|IV))?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>$2, $1$3</pre>
<pre>\2, \1\3</pre>
<h2>4.19. Validate Password Complexity</h2>
<h3>Solution</h3>
<h4>Length between 8 and 32 characters</h4>
<pre>^.{8,32}$</pre>
<p>Regex options: Dot
          matches line breaks (=E2=80=9C^ and $ match at line breaks=E2=80=
=9D must not be
          set)<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^[\s\S]{8,32}$</pre>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>ASCII visible and space characters only</h4>
<pre>^[\x20-\x7E]+$</pre>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>One or more uppercase letters</h4>
<pre>[A-Z]</pre>
<p>Regex options: None
          (=E2=80=9Ccase insensitive=E2=80=9D must not be set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\p{Lu}</pre>
<p>Regex options: None
          (=E2=80=9Ccase insensitive=E2=80=9D must not be set)<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby 1.9</p>
<h4>One or more lowercase letters</h4>
<pre>[a-z]</pre>
<p>Regex options: None
          (=E2=80=9Ccase insensitive=E2=80=9D must not be set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\p{Ll}</pre>
<p>Regex options: None
          (=E2=80=9Ccase insensitive=E2=80=9D must not be set)<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby 1.9</p>
<h4>One or more numbers</h4>
<pre>[0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>One or more special characters</h4>
<pre>[ !"#$%&amp;'()*+,\-./:;&lt;=3D&gt;?@[\\\]^_`{|}~]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>[^A-Za-z0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Disallow three or more sequential identical characters</h4>
<pre>(.)\1\1</pre>
<p>Regex options: Dot
          matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>([\s\S])\1\1</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Example JavaScript solution, basic</h4>
<pre>function validate(password) {
    var minMaxLength =3D /^[\s\S]{8,32}$/,
        upper =3D /[A-Z]/,
        lower =3D /[a-z]/,
        number =3D /[0-9]/,
        special =3D /[ !"#$%&amp;'()*+,\-./:;&lt;=3D&gt;?@[\\\]^_`{|}~]/;

    if (minMaxLength.test(password) &amp;&amp;
        upper.test(password) &amp;&amp;
        lower.test(password) &amp;&amp;
        number.test(password) &amp;&amp;
        special.test(password)
    ) {
        return true;
    }

    return false;
}</pre>
<h4>Example JavaScript solution, with x out of y validation</h4>
<pre>function validate(password) {
    var minMaxLength =3D /^[\s\S]{8,32}$/,
        upper =3D /[A-Z]/,
        lower =3D /[a-z]/,
        number =3D /[0-9]/,
        special =3D /[^A-Za-z0-9]/,
        count =3D 0;

    if (minMaxLength.test(password)) {
        // Only need 3 out of 4 of these to match
        if (upper.test(password)) count++;
        if (lower.test(password)) count++;
        if (number.test(password)) count++;
        if (special.test(password)) count++;
    }

    return count &gt;=3D 3;
}</pre>
<h4>Example JavaScript solution, with password security
        ranking</h4>
<pre>var rank =3D {
    TOO_SHORT: 0,
    WEAK: 1,
    MEDIUM: 2,
    STRONG: 3,
    VERY_STRONG: 4
};

function rankPassword(password) {
    var upper =3D /[A-Z]/,
        lower =3D /[a-z]/,
        number =3D /[0-9]/,
        special =3D /[^A-Za-z0-9]/,
        minLength =3D 8,
        score =3D 0;

    if (password.length &lt; minLength) {
        return rank.TOO_SHORT; // End early
    }

    // Increment the score for each of these conditions
    if (upper.test(password)) score++;
    if (lower.test(password)) score++;
    if (number.test(password)) score++;
    if (special.test(password)) score++;

    // Penalize if there aren't at least three char types
    if (score &lt; 3) score--;

    if (password.length &gt; minLength) {
        // Increment the score for every 2 chars longer than the minimum
        score +=3D Math.floor((password.length - minLength) / 2);
    }

    // Return a ranking based on the calculated score
    if (score &lt; 3) return rank.WEAK; // score is 2 or lower
    if (score &lt; 4) return rank.MEDIUM; // score is 3
    if (score &lt; 6) return rank.STRONG; // score is 4 or 5
    return rank.VERY_STRONG; // score is 6 or higher
}

// Test it...
var result =3D rankPassword("password1"),
    labels =3D ["Too Short", "Weak", "Medium", "Strong", "Very Strong"];

alert(labels[result]); // -&gt; Weak</pre>
<h3>Variations</h3>
<h4>Validate multiple password rules with a single regex</h4>
<pre>^(?=3D.{8,32}$)(?=3D.*[A-Z])(?=3D.*[a-z])(?=3D.*[0-9]).*</pre>
<p>Regex options: Dot
          matches line breaks (=E2=80=9C^ and $ match at line breaks=E2=80=
=9D must not be
          set)<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>4.20. Validate Credit Card Numbers</h2>
<h3>Solution</h3>
<h4>Strip spaces and hyphens</h4>
<pre>[ -]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Validate the number</h4>
<pre>^(?:
(?&lt;visa&gt;4[0-9]{12}(?:[0-9]{3})?) |
(?&lt;mastercard&gt;5[1-5][0-9]{14}) |
(?&lt;discover&gt;6(?:011|5[0-9]{2})[0-9]{12}) |
(?&lt;amex&gt;3[47][0-9]{13}) |
(?&lt;diners&gt;3(?:0[0-5]|[68][0-9])[0-9]{11}) |
(?&lt;jcb&gt;(?:2131|1800|35[0-9]{3})[0-9]{11})
)$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?:
(?P&lt;visa&gt;4[0-9]{12}(?:[0-9]{3})?) |
(?P&lt;mastercard&gt;5[1-5][0-9]{14}) |
(?P&lt;discover&gt;6(?:011|5[0-9]{2})[0-9]{12}) |
(?P&lt;amex&gt;3[47][0-9]{13}) |
(?P&lt;diners&gt;3(?:0[0-5]|[68][0-9])[0-9]{11}) |
(?P&lt;jcb&gt;(?:2131|1800|35[0-9]{3})[0-9]{11})
)$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: PCRE,
          Python</p>
<pre>^(?:
(4[0-9]{12}(?:[0-9]{3})?) |          # Visa
(5[1-5][0-9]{14}) |                  # MasterCard
(6(?:011|5[0-9]{2})[0-9]{12}) |      # Discover
(3[47][0-9]{13}) |                   # AMEX
(3(?:0[0-5]|[68][0-9])[0-9]{11}) |   # Diners Club
((?:2131|1800|35[0-9]{3})[0-9]{11})  # JCB
)$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-=
9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[=
0-9]{3})[0-9]{11}))$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Example web page with JavaScript</h4>
<pre>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Credit Card Test&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;h1&gt;Credit Card Test&lt;/h1&gt;

&lt;form&gt;
&lt;p&gt;Please enter your credit card number:&lt;/p&gt;

&lt;p&gt;&lt;input type=3D"text" size=3D"20" name=3D"cardnumber"
  onkeyup=3D"validatecardnumber(this.value)"&gt;&lt;/p&gt;

&lt;p id=3D"notice"&gt;(no card number entered)&lt;/p&gt;
&lt;/form&gt;

&lt;script&gt;
function validatecardnumber(cardnumber) {
  // Strip spaces and dashes
  cardnumber =3D cardnumber.replace(/[ -]/g, '');
  // See if the card is valid
  // The regex will capture the number in one of the capturing groups
  var match =3D /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5=
[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2=
131|1800|35[0-9]{3})[0-9]{11}))$/.exec(cardnumber);
  if (match) {
    // List of card types, in the same order as the regex capturing groups
    var types =3D ['Visa', 'MasterCard', 'Discover', 'American Express',
                 'Diners Club', 'JCB'];
    // Find the capturing group that matched
    // Skip the zeroth element of the match array (the overall match)
    for (var i =3D 1; i &lt; match.length; i++) {
      if (match[i]) {
        // Display the card type for that group
        document.getElementById('notice').innerHTML =3D types[i - 1];
        break;
      }
    }
  } else {
    document.getElementById('notice').innerHTML =3D '(invalid card number)'=
;
  }
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<h3>Discussion</h3>
<h4>Validate the number</h4>
<pre>^(?:
4[0-9]{12}(?:[0-9]{3})? |         # Visa
5[1-5][0-9]{14} |                 # MasterCard
3[47][0-9]{13}                    # AMEX
)$</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|3[47][0-9]{13})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Extra Validation with the Luhn Algorithm</h3>
<pre>function luhn(cardnumber) {
  // Build an array with the digits in the card number
  var digits =3D cardnumber.split('');
  for (var i =3D 0; i &lt; digits.length; i++) {
    digits[i] =3D parseInt(digits[i], 10);
  } =20
  // Run the Luhn algorithm on the array
  var sum =3D 0;
  var alt =3D false;
  for (i =3D digits.length - 1; i &gt;=3D 0; i--) {
    if (alt) {
      digits[i] *=3D 2;
      if (digits[i] &gt; 9) {
        digits[i] -=3D 9;
      }
    }
    sum +=3D digits[i];
    alt =3D !alt;
  }
  // Check the result
  if (sum % 10 =3D=3D 0) {
    document.getElementById('notice').innerHTML +=3D '; Luhn check passed';
  } else {
    document.getElementById('notice').innerHTML +=3D '; Luhn check failed';
  }
}</pre>
<h2>4.21. European VAT Numbers</h2>
<h3>Solution</h3>
<h4>Strip whitespace and punctuation</h4>
<pre>[-. ]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Validate the number</h4>
<pre>^(
(AT)?U[0-9]{8} |                              # Austria
(BE)?0[0-9]{9} |                              # Belgium
(BG)?[0-9]{9,10} |                            # Bulgaria
(CY)?[0-9]{8}L |                              # Cyprus
(CZ)?[0-9]{8,10} |                            # Czech Republic
(DE)?[0-9]{9} |                               # Germany
(DK)?[0-9]{8} |                               # Denmark
(EE)?[0-9]{9} |                               # Estonia
(EL|GR)?[0-9]{9} |                            # Greece
(ES)?[0-9A-Z][0-9]{7}[0-9A-Z] |               # Spain
(FI)?[0-9]{8} |                               # Finland
(FR)?[0-9A-Z]{2}[0-9]{9} |                    # France
(GB)?([0-9]{9}([0-9]{3})?|[A-Z]{2}[0-9]{3}) | # United Kingdom
(HU)?[0-9]{8} |                               # Hungary
(IE)?[0-9]S[0-9]{5}L |                        # Ireland
(IT)?[0-9]{11} |                              # Italy
(LT)?([0-9]{9}|[0-9]{12}) |                   # Lithuania
(LU)?[0-9]{8} |                               # Luxembourg
(LV)?[0-9]{11} |                              # Latvia
(MT)?[0-9]{8} |                               # Malta
(NL)?[0-9]{9}B[0-9]{2} |                      # Netherlands
(PL)?[0-9]{10} |                              # Poland
(PT)?[0-9]{9} |                               # Portugal
(RO)?[0-9]{2,10} |                            # Romania
(SE)?[0-9]{12} |                              # Sweden
(SI)?[0-9]{8} |                               # Slovenia
(SK)?[0-9]{10}                                # Slovakia
)$</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^((AT)?U[0-9]{8}|(BE)?0[0-9]{9}|(BG)?[0-9]{9,10}|(CY)?[0-9]{8}L|(CZ)?[=
0-9]{8,10}|(DE)?[0-9]{9}|(DK)?[0-9]{8}|(EE)?[0-9]{9}|(EL|GR)?[0-9]{9}|(ES)?=
[0-9A-Z][0-9]{7}[0-9A-Z]|(FI)?[0-9]{8}|(FR)?[0-9A-Z]{2}[0-9]{9}|(GB)?([0-9]=
{9}([0-9]{3})?|[A-Z]{2}[0-9]{3})|(HU)?[0-9]{8}|(IE)?[0-9]S[0-9]{5}L|(IT)?[0=
-9]{11}|(LT)?([0-9]{9}|[0-9]{12})|(LU)?[0-9]{8}|(LV)?[0-9]{11}|(MT)?[0-9]{8=
}|(NL)?[0-9]{9}B[0-9]{2}|(PL)?[0-9]{10}|(PT)?[0-9]{9}|(RO)?[0-9]{2,10}|(SE)=
?[0-9]{12}|(SI)?[0-9]{8}|(SK)?[0-9]{10})$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h1>5. Words, Lines, and Special Characters</h1>
<h2>5.1. Find a Specific Word</h2>
<h3>Solution</h3>
<pre>\bcat\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>// 8-bit-wide letter characters
var pL =3D "A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\xFF",
    pattern =3D "([^{L}]|^)cat([^{L}]|$)".replace(/{L}/g, pL),
    regex =3D new RegExp(pattern, "gi");

// replace cat with dog, and put back any
// additional matched characters
subject =3D subject.replace(regex, "$1dog$2");</pre>
<h2>5.2. Find Any of Multiple Words</h2>
<h3>Solution</h3>
<h4>Using alternation</h4>
<pre>\b(?:one|two|three)\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Example JavaScript solution</h4>
<pre>var subject =3D "One times two plus one equals three.";

// Solution 1:

var regex =3D /\b(?:one|two|three)\b/gi;

subject.match(regex);
// Returns an array with four matches: ["One","two","one","three"]

// Solution 2 (reusable):

// This function does the same thing but accepts an array of words to
// match. Any regex metacharacters within the accepted words are escaped
// with a backslash before searching.

function matchWords(subject, words) {
    var regexMetachars =3D /[(){[*+?.\\^$|]/g;

    for (var i =3D 0; i &lt; words.length; i++) {
        words[i] =3D words[i].replace(regexMetachars, "\\$&amp;");
    }

    var regex =3D new RegExp("\\b(?:" + words.join("|") + ")\\b", "gi");

    return subject.match(regex) || [];
}

matchWords(subject, ["one","two","three"]);
// Returns an array with four matches: ["One","two","one","three"]</pre>
<h2>5.3. Find Similar Words</h2>
<h3>Solution</h3>
<h4>Color or colour</h4>
<pre>\bcolou?r\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Bat, cat, or rat</h4>
<pre>\b[bcr]at\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Words ending with =E2=80=9Cphobia=E2=80=9D</h4>
<pre>\b\w*phobia\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Steve, Steven, or Stephen</h4>
<pre>\bSte(?:ven?|phen)\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Variations of =E2=80=9Cregular expression=E2=80=9D</h4>
<pre>\breg(?:ular expressions?|ex(?:ps?|e[sn])?)\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<h4>Variations of =E2=80=9Cregular expression=E2=80=9D</h4>
<pre>\b              # Assert position at a word boundary.
reg             # Match "reg".
(?:             # Group but don't capture:
  ular\         #   Match "ular ".
  expressions?  #   Match "expression" or "expressions".
 |              #  Or:
  ex            #   Match "ex".
  (?:           #   Group but don't capture:
    ps?         #     Match "p" or "ps".
   |            #    Or:
    e[sn]       #     Match "es" or "en".
  )?            #   End the group and make it optional.
)               # End the group.
\b              # Assert position at a word boundary.</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>5.4. Find All Except a Specific Word</h2>
<h3>Solution</h3>
<pre>\b(?!cat\b)\w+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>\b     # Assert position at a word boundary.
(?!    # Not followed by:
  cat  #   Match "cat".
  \b   #   Assert position at a word boundary.
)      # End the negative lookahead.
\w+    # Match one or more word characters.</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Find words that don=E2=80=99t contain another word</h4>
<pre>\b(?:(?!cat)\w)+\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>5.5. Find Any Word Not Followed by a Specific Word</h2>
<h3>Solution</h3>
<pre>\b\w+\b(?!\W+cat\b)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>\b\w+\b(?=3D\W+cat\b)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>5.6. Find Any Word Not Preceded by a Specific Word</h2>
<h3>Solution</h3>
<h4>Words not preceded by =E2=80=9Ccat=E2=80=9D</h4>
<pre>(?&lt;!\bcat\W+)\b\w+</pre>
<p>Regex options: Case
          insensitive<br>
</p><pre>(?&lt;!\bcat\W{1,9})\b\w+</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java</p>
<pre>(?&lt;!\bcat\W)\b\w+</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python</p>
<pre>(?&lt;!\Wcat\W)(?&lt;!^cat\W)\b\w+</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<h4>Simulate lookbehind</h4>
<pre>var subject =3D "My cat is fluffy.",
    mainRegex =3D /\b\w+/g,
    lookbehind =3D /\bcat\W+$/i,
    lookbehindType =3D false, // false for negative, true for positive
    matches =3D [],
    match,
    leftContext;

while (match =3D mainRegex.exec(subject)) {
    leftContext =3D subject.substring(0, match.index);

    if (lookbehindType =3D=3D lookbehind.test(leftContext)) {
        matches.push(match[0]);
    } else {
        mainRegex.lastIndex =3D match.index + 1;
    }
}

// matches:  ["My", "cat", "fluffy"]</pre>
<h3>Variations</h3>
<pre>(?&lt;=3D\bcat\W+)\w+</pre>
<p>Regex options: Case
        insensitive<br>
</p><pre>(?&lt;=3D\bcat\W{1,9})\w+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java</p>
<pre>(?&lt;=3D\bcat\W)\w+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python</p>
<pre>(?:(?&lt;=3D\Wcat\W)|(?&lt;=3D^cat\W))\w+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>\bcat\W+\K\w+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: PCRE
        7.2, Perl 5.10</p>
<h2>5.7. Find Words Near Each Other</h2>
<h3>Solution</h3>
<pre>\b(?:word1\W+(?:\w+\W+){0,5}?word2|word2\W+(?:\w+\W+){0,5}?word1)\b</p=
re>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:
  word1                 # first term
  \W+ (?:\w+\W+){0,5}?  # up to five words
  word2                 # second term
|                       #   or, the same pattern in reverse:
  word2                 # second term
  \W+ (?:\w+\W+){0,5}?  # up to five words
  word1                 # first term
)\b</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Using a conditional</h4>
<pre>\b(?:word1|(word2))\W+(?:\w+\W+){0,5}?(?(1)word1|word2)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          PCRE, Perl, Python</p>
<pre>\b(?:(?&lt;w1&gt;word1)|(?&lt;w2&gt;word2))\W+(?:\w+\W+){0,5}?(?(w2)(?=
&amp;w1)|(?&amp;w2))\b</pre>
<p>Regex options: None<br>
Regex flavors: PCRE
          7, Perl 5.10</p>
<h4>Match three or more words near each other</h4>
<pre>\b(?:(?&gt;(word1)|(word2)|(word3)|(?(1)|(?(2)|(?(3)|(?!))))\w+)\b\W*?=
){3,8}(?(1)(?(2)(?(3)|(?!))|(?!))|(?!))</pre>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, PCRE, Perl</p>
<pre>\b(?:(?:(word1)|(word2)|(word3)|(?(1)|(?(2)|(?(3)|(?!))))\w+)\b\W*?){3=
,8}(?(1)(?(2)(?(3)|(?!))|(?!))|(?!))</pre>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, PCRE, Perl, Python</p>
<pre>\b(?:(?&gt;word1()|word2()|word3()|(?&gt;\1|\2|\3)\w+)\b\W*?){3,8}\1\2=
\3</pre>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, Java, PCRE, Perl, Ruby</p>
<pre>\b(?:(?:word1()|word2()|word3()|(?:\1|\2|\3)\w+)\b\W*?){3,8}\1\2\3</pr=
e>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, Java, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:(?&gt;word1()|word2()|word3()|word4()|(?&gt;\1|\2|\3|\4)\w+)\b\W*=
?){4,9}\1\2\3\4</pre>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, Java, PCRE, Perl, Ruby</p>
<pre>\b(?:(?:word1()|word2()|word3()|word4()|(?:\1|\2|\3|\4)\w+)\b\W*?){4,9=
}\1\2\3\4</pre>
<p>Regex options: Case
            insensitive<br>
Regex flavors: .NET, Java, PCRE, Perl, Python, Ruby</p>
<h4>Multiple words, any distance from each other</h4>
<pre>^(?=3D.*?\bword1\b)(?=3D.*?\bword2\b).*</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks (=E2=80=9C^ and $ match at l=
ine breaks=E2=80=9D
          must not be set)<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(?=3D[\s\S]*?\bword1\b)(?=3D[\s\S]*?\bword2\b)[\s\S]*</pre>
<p>Regex options: Case
          insensitive (=E2=80=9C^ and $ match at line breaks=E2=80=9D must =
not be
          set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>5.8. Find Repeated Words</h2>
<h3>Solution</h3>
<pre>\b([A-Z]+)\s+\1\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>(?&lt;![\p{L}\p{M}\-'\u2019])([\-'\u2019]?(?:[\p{L}\p{M}][\-'\u2019]?)=
+)\s+\1(?![\p{L}\p{M}\-'\u2019])</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, Ruby 1.9</p>
<pre>(?&lt;![\p{L}\p{M}\-'\x{2019}])([\-'\x{2019}]?(?:[\p{L}\p{M}][\-'\x{20=
19}]?)+)\s+\1(?![\p{L}\p{M}\-'\x{2019}])</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: Java 7,
        PCRE, Perl</p>
<h2>5.9. Remove Duplicate Lines</h2>
<h3>Solution</h3>
<h4>Option 1: Sort lines and remove adjacent duplicates</h4>
<pre>^(.*)(?:(?:\r?\n|\r)\1)+$</pre>
<p>Regex options: ^ and
          $ match at line breaks (=E2=80=9Cdot matches line breaks=E2=80=9D=
 must not be
          set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>$1</pre>
<pre>\1</pre>
<h4>Option 2: Keep the last occurrence of each duplicate line in an
        unsorted file</h4>
<pre>^([^\r\n]*)(?:\r?\n|\r)(?=3D.*^\1$)</pre>
<p>Regex options: Dot
          matches line breaks, ^ and $ match at line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(.*)(?:\r?\n|\r)(?=3D[\s\S]*^\1$)</pre>
<p>Regex options: ^ and
          $ match at line breaks (=E2=80=9Cdot matches line breaks=E2=80=9D=
 must not be
          set)<br>
</p><h4>Option 3: Keep the first occurrence of each duplicate line in
        an unsorted file</h4>
<pre>^([^\r\n]*)$(.*?)(?:(?:\r?\n|\r)\1$)+</pre>
<p>Regex options: Dot
          matches line breaks, ^ and $ match at line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>^(.*)$([\s\S]*?)(?:(?:\r?\n|\r)\1$)+</pre>
<p>Regex options: ^ and
          $ match at line breaks (=E2=80=9Cdot matches line breaks=E2=80=9D=
 must not be
          set)<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>$1$2</pre>
<pre>\1\2</pre>
<h3>Discussion</h3>
<h4>Option 3: Keep the first occurrence of each duplicate line in
        an unsorted file</h4>
<pre>value1
value2
value2
value3
value3
value1
value2</pre>
<h2>5.10. Match Complete Lines That Contain a Word</h2>
<h3>Solution</h3>
<pre>^.*\berror\b.*$</pre>
<p>Regex options: Case
        insensitive, ^ and $ match at line breaks (=E2=80=9Cdot matches lin=
e breaks=E2=80=9D
        must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>^.*\b(one|two|three)\b.*$</pre>
<p>Regex options: Case
        insensitive, ^ and $ match at line breaks (=E2=80=9Cdot matches lin=
e breaks=E2=80=9D
        must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?=3D.*?\bone\b)(?=3D.*?\btwo\b)(?=3D.*?\bthree\b).+$</pre>
<p>Regex options: Case
        insensitive, ^ and $ match at line breaks (=E2=80=9Cdot matches lin=
e breaks=E2=80=9D
        must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>5.11. Match Complete Lines That Do Not Contain a Word</h2>
<h3>Solution</h3>
<pre>^(?:(?!\berror\b).)*$</pre>
<p>Regex options: Case
        insensitive, ^ and $ match at line breaks (=E2=80=9Cdot matches lin=
e breaks=E2=80=9D
        must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>5.12. Trim Leading and Trailing Whitespace</h2>
<h3>Solution</h3>
<pre>\A\s+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^\s+</pre>
<p>Regex options: None (=E2=80=9C^
        and $ match at line breaks=E2=80=9D must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\s+\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\s+$</pre>
<p>Regex options: None (=E2=80=9C^
        and $ match at line breaks=E2=80=9D must not be set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<h3>Discussion</h3>
<pre>sub trim {
    my $string =3D shift;
    $string =3D~ s/^\s+//;
    $string =3D~ s/\s+$//;
    return $string;
}</pre>
<pre>// Add the trim method for browsers that don't already include it
if (!String.prototype.trim) {
    String.prototype.trim =3D function() {
        return this.replace(/^\s+/, "").replace(/\s+$/, "");
    };
}</pre>
<h2>5.13. Replace Repeated Whitespace with a Single Space</h2>
<h3>Solution</h3>
<h4>Clean any whitespace characters</h4>
<pre>\s+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Clean horizontal whitespace characters</h4>
<pre>[ \t\xA0]+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby 1.8</p>
<pre>[ \t\u00A0]+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, Python, Ruby 1.9</p>
<pre>\h+</pre>
<p>Regex options: None<br>
Regex flavors: PCRE
          7.2, Perl 5.10</p>
<h2>5.14. Escape Regular Expression Metacharacters</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>[[\]{}()*+?.\\|^$\-,&amp;#\s]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>\$&amp;</pre>
<pre>\$0</pre>
<pre>\\$&amp;</pre>
<pre>\\$0</pre>
<pre>\\\0</pre>
<pre>\\\&amp;</pre>
<pre>\\\g&lt;0&gt;</pre>
<h4>Example JavaScript function</h4>
<pre>RegExp.escape =3D function(str) {
    return str.replace(/[[\]{}()*+?.\\|^$\-,&amp;#\s]/g, "\\$&amp;");
};

// Test it...
var str =3D "&lt;Hello World.&gt;";
var escapedStr =3D RegExp.escape(str);
alert(escapedStr =3D=3D "&lt;Hello\\ World\\.&gt;"); // -&gt; true</pre>
<h1>6. Numbers</h1>
<h2>6.1. Integer Numbers</h2>
<h3>Solution</h3>
<pre>\b[0-9]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A[0-9]+\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>(?&lt;=3D^|\s)[0-9]+(?=3D$|\s)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Ruby 1.9</p>
<pre>(?:^|(?&lt;=3D\s))[0-9]+(?=3D$|\s)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>(^|\s)([0-9]+)(?=3D$|\s)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>[+-]?\b[0-9]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A[+-]?[0-9]+\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^[+-]?[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>([+-] *)?\b[0-9]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.2. Hexadecimal Numbers</h2>
<h3>Solution</h3>
<pre>\b[0-9A-F]+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-Fa-f]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A[0-9A-F]+\Z</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^[0-9A-F]+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\b0x[0-9A-F]+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&amp;H[0-9A-F]+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-F]+H\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-F]{2}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-F]{4}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-F]{8}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9A-F]{16}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:[0-9A-F]{2})+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.3. Binary Numbers</h2>
<h3>Solution</h3>
<pre>\b[01]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A[01]+\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^[01]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\b0b[01]+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[01]+B\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[01]{8}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[01]{16}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:[01]{8})+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.4. Octal Numbers</h2>
<h3>Solution</h3>
<pre>\b0[0-7]*\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A0[0-7]*\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^0[0-7]*$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\b0o[0-7]+\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.5. Decimal Numbers</h2>
<h3>Solution</h3>
<pre>\b(0|[1-9][0-9]*)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A(0|[1-9][0-9]*)\Z</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^(0|[1-9][0-9]*)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<h2>6.6. Strip Leading Zeros</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>\b0*([1-9][0-9]*|0)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement</h4>
<pre>$1</pre>
<pre>\1</pre>
<h4>Getting the numbers in Perl</h4>
<pre>while ($subject =3D~ m/\b0*([1-9][0-9]*|0)\b/g) {
    push(@list, $1);
}</pre>
<h4>Stripping leading zeros in PHP</h4>
<pre>$result =3D preg_replace('/\b0*([1-9][0-9]*|0)\b/', '$1', $subject);</=
pre>
<h2>6.7. Numbers Within a Certain Range</h2>
<h3>Solution</h3>
<pre>^(1[0-2]|[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(2[0-4]|1[0-9]|[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3[01]|[12][0-9]|[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(5[0-3]|[1-4][0-9]|[1-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[1-5]?[0-9]$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(100|[1-9]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(100|[1-9][0-9]?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(12[0-6]|1[01][0-9]|[4-9][0-9]|3[2-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(12[0-7]|1[01][0-9]|[1-9]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(12[0-7]|1[01][0-9]|[1-9]?[0-9]|-(12[0-8]|1[01][0-9]|[1-9]?[0-9]))$</=
pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(36[0-6]|3[0-5][0-9]|[12][0-9]{2}|[1-9][0-9]?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(19|20)[0-9]{2}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3276[0-7]|327[0-5][0-9]|32[0-6][0-9]{2}|3[01][0-9]{3}|[12][0-9]{4}|[=
1-9][0-9]{1,3}|[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3276[0-7]|327[0-5][0-9]|32[0-6][0-9]{2}|3[01][0-9]{3}|[12][0-9]{4}|[=
1-9][0-9]{1,3}|[0-9]|-(3276[0-8]|327[0-5][0-9]|32[0-6][0-9]{2}|3[01][0-9]{3=
}|[12][0-9]{4}|[1-9][0-9]{1,3}|[0-9]))$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}=
|[1-9][0-9]{1,3}|[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>[45][0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>4[4-9]|5[0-5]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>3[4-9]|[45][0-9]|6[0-5]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>1[0-2]|[1-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>8[5-9]|9[0-9]|10[0-9]|11[0-7]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>6553[0-5]|655[0-2][0-9]|65[0-4][0-9][0-9]|6[0-4][0-9][0-9][0-9]|[1-5][=
0-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9]|[0-9]</=
pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[=
1-9][0-9]{3}|[1-9][0-9]{2}|[1-9][0-9]|[0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>6553[0-5]|655[0-2][0-9]|65[0-4][0-9]{2}|6[0-4][0-9]{3}|[1-5][0-9]{4}|[=
1-9][0-9]{1,3}|[0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>6(?:553[0-5]|55[0-2][0-9]|5[0-4][0-9]{2}|[0-4][0-9]{3})|[1-5][0-9]{4}|=
[1-9][0-9]{1,3}|[0-9]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.8. Hexadecimal Numbers Within a Certain Range</h2>
<h3>Solution</h3>
<pre>^[1-9a-c]$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(1[0-8]|[1-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(1[0-9a-f]|[1-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3[0-5]|[12][0-9a-f]|[1-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(3[0-9a-b]|[12]?[0-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(6[0-4]|[1-5]?[0-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(6[0-4]|[1-5][0-9a-f]|[1-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(7[0-9a-e]|[2-6][0-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[1-7]?[0-9a-f]$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[1-9a-f]?[0-9a-f]$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(16[0-9a-e]|1[0-5][0-9a-f]|[1-9a-f][0-9a-f]?)$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(83[0-3]|8[0-2][0-9a-f]|7[7-9a-f][0-9a-f]|76[c-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^([1-7][0-9a-f]{3}|[1-9a-f][0-9a-f]{1,2}|[0-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^([1-9a-f][0-9a-f]{1,3}|[0-9a-f])$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.9. Integer Numbers with Separators</h2>
<h3>Solution</h3>
<pre>\b[0-9]+(_+[0-9]+)*\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b0x[0-9A-F]+(_+[0-9A-F]+)*\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b0b[01]+(_+[01]+)*\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b([0-9]+(_+[0-9]+)*|0x[0-9A-F]+(_+[0-9A-F]+)*|0b[01]+(_+[01]+)*)\b</p=
re>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A([0-9]+(_+[0-9]+)*|0x[0-9A-F]+(_+[0-9A-F]+)*|0b[01]+(_+[01]+)*)\Z</p=
re>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^([0-9]+(_+[0-9]+)*|0x[0-9A-F]+(_+[0-9A-F]+)*|0b[01]+(_+[01]+)*)$</pre=
>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<h2>6.10. Floating-Point Numbers</h2>
<h3>Solution</h3>
<pre>^[-+][0-9]+\.[0-9]+[eE][-+]?[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+][0-9]+\.[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?[0-9]+\.[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?[0-9]*\.[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?([0-9]+(\.[0-9]+)?|\.[0-9]+)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?([0-9]+(\.[0-9]*)?|\.[0-9]+)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?([0-9]+(\.[0-9]+)?|\.[0-9]+)([eE][-+]?[0-9]+)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[-+]?([0-9]+(\.[0-9]*)?|\.[0-9]+)([eE][-+]?[0-9]+)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>[-+]?(\b[0-9]+(\.[0-9]*)?|\.[0-9]+)([eE][-+]?[0-9]+\b)?</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.11. Numbers with Thousand Separators</h2>
<h3>Solution</h3>
<pre>^[0-9]{1,3}(,[0-9]{3})*\.[0-9]+$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[0-9]{1,3}(,[0-9]{3})*(\.[0-9]+)?$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^([0-9]{1,3}(,[0-9]{3})*(\.[0-9]+)?|\.[0-9]+)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b[0-9]{1,3}(,[0-9]{3})*(\.[0-9]+)?\b|\.[0-9]+\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>6.12. Add Thousand Separators to Numbers</h2>
<h3>Solution</h3>
<h4>Basic solution</h4>
<pre>[0-9](?=3D(?:[0-9]{3})+(?![0-9]))</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>$&amp;,</pre>
<pre>$0,</pre>
<pre>\0,</pre>
<pre>\&amp;,</pre>
<pre>\g&lt;0&gt;,</pre>
<h4>Match separator positions only, using lookbehind</h4>
<pre>(?&lt;=3D[0-9])(?=3D(?:[0-9]{3})+(?![0-9]))</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>,</pre>
<h3>Variations</h3>
<h4>Don=E2=80=99t add commas after a decimal point</h4>
<pre>[0-9](?=3D(?:[0-9]{3})+(?![0-9]))(?&lt;!\.[0-9]+)</pre>
<p>Regex options: None<br>
Regex flavors: .NET</p>
<pre>[0-9](?=3D(?:[0-9]{3})+(?![0-9]))(?&lt;!\.[0-9]{1,100})</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java</p>
<pre>$0,</pre>
<pre>\b(?&lt;!\.)[0-9]{4,}</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>subject.gsub(/\b(?&lt;!\.)[0-9]{4,}/) {|match|
    match.gsub(/[0-9](?=3D(?:[0-9]{3})+(?![0-9]))/, '\0,')
}</pre>
<pre>subject.replace(/(^|[^0-9.])([0-9]{4,})/g, function($0, $1, $2) {
    return $1 + $2.replace(/[0-9](?=3D(?:[0-9]{3})+(?![0-9]))/g, "$&amp;,")=
;
});</pre>
<pre>subject.split(").reverse().join(").replace(/[0-9]{3}(?=3D[0-9])(?![0-9=
]*\.)/g, "$&amp;,").split(").reverse().join(");</pre>
<pre>function commafy(num) {
    num =3D String(num);
    var numParts =3D /^([0-9]+)(\.[0-9]+)?$/.exec(num);
    var result =3D numParts[1].replace(/[0-9](?=3D(?:[0-9]{3})+(?![0-9]))/,=
 "$&amp;,");
    if (numParts[2]) {
        result +=3D numParts[2];
    }
    return result;
}

// Test it...
commafy(10000); // "10,000"
commafy(10000.1234); // "10,000.1234"
commafy(.1234); // "0.1234"
commafy("a"); // Throws a TypeError</pre>
<h2>6.13. Roman Numerals</h2>
<h3>Solution</h3>
<pre>^[MDCLXVI]+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?=3D[MDCLXVI])M*(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$</p=
re>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?=3D[MDCLXVI])M*(C[MD]|D?C*)(X[CL]|L?X*)(I[XV]|V?I*)$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?=3D[MDCLXVI])M*D?C{0,4}L?X{0,4}V?I{0,4}$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Convert Roman Numerals to Decimal</h3>
<pre>sub roman2decimal {
    my $roman =3D shift;
    if ($roman =3D~
        m/^(?=3D[MDCLXVI])
          (M*)               # 1000
          (C[MD]|D?C{0,3})   # 100
          (X[CL]|L?X{0,3})   # 10
          (I[XV]|V?I{0,3})   # 1
          $/ix)
    {
        # Roman numeral found
        my %r2d =3D ('I' =3D&gt;    1, 'IV' =3D&gt;   4, 'V' =3D&gt;   5, '=
IX' =3D&gt;   9,
                   'X' =3D&gt;   10, 'XL' =3D&gt;  40, 'L' =3D&gt;  50, 'XC=
' =3D&gt;  90,
                   'C' =3D&gt;  100, 'CD' =3D&gt; 400, 'D' =3D&gt; 500, 'CM=
' =3D&gt; 900,
                   'M' =3D&gt; 1000);
        my $decimal =3D 0;
        while ($roman =3D~ m/[MDLV]|C[MD]?|X[CL]?|I[XV]?/ig) {
            $decimal +=3D $r2d{uc($&amp;)};
        }
        return $decimal;
    } else {
        # Not a Roman numeral
        return 0;
    }
}</pre>
<h1>7. Source Code and Log Files</h1>
<h2>7.1. Keywords</h2>
<h3>Solution</h3>
<pre>\b(?:end|in|inline|inherited|item|object)\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?&gt;end|in(?:line|herited)?|item|object)\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>object Button1: TButton
    Caption =3D 'The end is near'
end</pre>
<pre>\b(end|in|inline|inherited|item|object)\b|'[^'\r\n]*(?:''[^'\r\n]*)*'<=
/pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.2. Identifiers</h2>
<h3>Solution</h3>
<pre>\b[a-z_][0-9a-z_]{0,31}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.3. Numeric Constants</h2>
<h3>Solution</h3>
<pre>\b(?:(?&lt;dec&gt;[1-9][0-9]*)
   | (?&lt;oct&gt;0[0-7]*)
   | 0x(?&lt;hex&gt;[0-9A-F]+)
   | 0b(?&lt;bin&gt;[01]+)
  )(?&lt;L&gt;L)?\b</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\b(?:(?P&lt;dec&gt;[1-9][0-9]*)
   | (?P&lt;oct&gt;0[0-7]*)
   | 0x(?P&lt;hex&gt;[0-9A-F]+)
   | 0b(?P&lt;bin&gt;[01]+)
  )(?P&lt;L&gt;L)?\b</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4,
        Perl 5.10, Python</p>
<pre>\b(?:([1-9][0-9]*)|(0[0-7]*)|0x([0-9A-F]+)|0b([01]+))(L)?\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.4. Operators</h2>
<h3>Solution</h3>
<pre>[-+*/=3D&lt;&gt;%&amp;^|!~?]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.5. Single-Line Comments</h2>
<h3>Solution</h3>
<pre>//.*</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.6. Multiline Comments</h2>
<h3>Solution</h3>
<pre>/\*.*?\*/</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>/\*[\s\S]*?\*/</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>/\*.*?(?:\*/)?</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>/\*[\s\S]*?(?:\*/)?</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.7. All Comments</h2>
<h3>Solution</h3>
<pre>(?-s://.*)|(?s:/\*.*?\*/)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, PCRE, Perl</p>
<pre>(?-m://.*)|(?m:/\*.*?\*/)</pre>
<p>Regex options: None<br>
Regex flavors: Ruby</p>
<pre>//[^\r\n]*|/\*.*?\*/</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>//.*|/\*[\s\S]*?\*/</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.8. Strings</h2>
<h3>Solution</h3>
<pre>"[^"\r\n]*(?:""[^"\r\n]*)*"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>'[^'\r\n]*(?:''[^'\r\n]*)*'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\r\n]*(?:""[^"\r\n]*)*"|'[^'\r\n]*(?:''[^'\r\n]*)*'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"]*(?:""[^"]*)*"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\r\n]*(?:""[^"\r\n]*)*"?</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.9. Strings with Escapes</h2>
<h3>Solution</h3>
<pre>"[^"\\\r\n]*(?:\\.[^"\\\r\n]*)"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>'[^'\\\r\n]*(?:\\.[^'\\\r\n]*)'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\\\r\n]*(?:\\.[^"\\\r\n]*)"|'[^'\\\r\n]*(?:\\.[^'\\\r\n]*)'</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\\\r\n]*(?:\\(?:.|\r?\n)[^"\\\r\n]*)"</pre>
<p>Regex options: None
        (make sure =E2=80=9Cdot matches line breaks=E2=80=9D is off)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\\]*(?:\\.[^"\\]*)*"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>"[^"\\]*(?:\\[\s\S][^"\\]*)*"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.10. Regex Literals</h2>
<h3>Solution</h3>
<pre>(?&lt;=3D[=3D:(,](?:\s*!)?\s*)/[^/\\\r\n]*(?:\\.[^/\\\r\n]*)*/</pre>
<p>Regex options: None<br>
Regex flavors: .NET</p>
<pre>[=3D:(,](?:\s*!)?\s*\K/[^/\\\r\n]*(?:\\.[^/\\\r\n]*)*/</pre>
<p>Regex options: None<br>
Regex flavors: PCRE
        7.2, Perl 5.10</p>
<pre>(?&lt;=3D[=3D:(,](?:\s{0,10}+!)?\s{0,10})/[^/\\\r\n]*(?:\\.[^/\\\r\n]*=
)*/</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java</p>
<pre>[=3D:(,](?:\s*!)?+\s*(/[^/\\\r\n]*(?:\\.[^/\\\r\n]*)*/)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.11. Here Documents</h2>
<h3>Solution</h3>
<pre>&lt;&lt;(["']?)([A-Za-z]+)\b\1.*?^\2\b</pre>
<p>Regex options: Dot
        matches line breaks, ^ and $ match at line breaks<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;&lt;(["']?)([A-Za-z]+)\b\1[\s\S]*?^\2\b</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.12. Common Log Format</h2>
<h3>Solution</h3>
<pre>^(?&lt;client&gt;\S+) \S+ (?&lt;userid&gt;\S+) \[(?&lt;datetime&gt;[^\=
]]+)\] "(?&lt;method&gt;[A-Z]+) (?&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?&=
lt;status&gt;[0-9]{3}) (?&lt;size&gt;[0-9]+|-)</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?P&lt;client&gt;\S+) \S+ (?P&lt;userid&gt;\S+) \[(?P&lt;datetime&gt;=
[^\]]+)\] "(?P&lt;method&gt;[A-Z]+) (?P&lt;request&gt;[^ "]+)? HTTP/[0-9.]+=
" (?P&lt;status&gt;[0-9]{3}) (?P&lt;size&gt;[0-9]+|-)</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: PCRE 4,
        Perl 5.10, Python</p>
<pre>^(\S+) \S+ (\S+) \[([^\]]+)\] "([A-Z]+) ([^ "]+)? HTTP/[0-9.]+" ([0-9]=
{3}) ([0-9]+|-) "([^"]*)" "([^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>^(?&lt;client&gt;\S+) \S+ (?&lt;userid&gt;\S+) \[(?&lt;day&gt;[0-9]{2}=
)/(?&lt;month&gt;[A-Za-z]+)/(?&lt;year&gt;[0-9]{4}):(?&lt;hour&gt;[0-9]{2})=
:(?&lt;min&gt;[0-9]{2}):(?&lt;sec&gt;[0-9]{2}) (?&lt;zone&gt;[-+][0-9]{4})\=
] "(?&lt;method&gt;[A-Z]+) (?&lt;file&gt;[^#? "]+)(?&lt;parameters&gt;[#?][=
^ "]*)? HTTP/[0-9.]+" (?&lt;status&gt;[0-9]{3}) (?&lt;size&gt;[0-9]+|-)</pr=
e>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?P&lt;client&gt;\S+) \S+ (?P&lt;userid&gt;\S+) \[(?P&lt;day&gt;[0-9]=
{2})/(?P&lt;month&gt;[A-Za-z]+)/(?P&lt;year&gt;[0-9]{4}):(?P&lt;hour&gt;[0-=
9]{2}):(?P&lt;min&gt;[0-9]{2}):(?P&lt;sec&gt;[0-9]{2}) (?P&lt;zone&gt;[-+][=
0-9]{4})\] "(?P&lt;method&gt;[A-Z]+) (?P&lt;file&gt;[^#? "]+)(?P&lt;paramet=
ers&gt;[#?][^ "]*)? HTTP/[0-9.]+" (?P&lt;status&gt;[0-9]{3}) (?P&lt;size&gt=
;[0-9]+|-)</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: PCRE 4,
        Perl 5.10, Python</p>
<pre>^(\S+) \S+ (\S+) \[([0-9]{2})/([A-Za-z]+)/([0-9]{4}):([0-9]{2}):([0-9]=
{2}):([0-9]{2}) ([\-+][0-9]{4})\] "([A-Z]+) ([^#? "]+)([#?][^ "]*)? HTTP/[0=
-9.]+" ([0-9]{3}) ([0-9]+|-)</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.13. Combined Log Format</h2>
<h3>Solution</h3>
<pre>^(?&lt;client&gt;\S+) \S+ (?&lt;userid&gt;\S+) \[(?&lt;datetime&gt;[^\=
]]+)\] "(?&lt;method&gt;[A-Z]+) (?&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?&=
lt;status&gt;[0-9]{3}) (?&lt;size&gt;[0-9]+|-) "(?&lt;referrer&gt;[^"]*)" "=
(?&lt;useragent&gt;[^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?P&lt;client&gt;\S+) \S+ (?P&lt;userid&gt;\S+) \[(?P&lt;datetime&gt;=
[^\]]+)\] "(?P&lt;method&gt;[A-Z]+) (?P&lt;request&gt;[^ "]+)? HTTP/[0-9.]+=
" (?P&lt;status&gt;[0-9]{3}) (?P&lt;size&gt;[0-9]+|-) "(?P&lt;referrer&gt;[=
^"]*)" "(?P&lt;useragent&gt;[^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: PCRE 4,
        Perl 5.10, Python</p>
<pre>^(\S+) \S+ (\S+) \[([^\]]+)\] "([A-Z]+) ([^ "]+)? HTTP/[0-9.]+" ([0-9]=
{3}) ([0-9]+|-) "([^"]*)" "([^"]*)" "([^"]*)" "([^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>7.14. Broken Links Reported in Web Logs</h2>
<h3>Solution</h3>
<pre>"(?:GET|POST) (?&lt;file&gt;[^#? "]+)(?:[#?][^ "]*)? HTTP/[0-9.]+" 404=
 (?:[0-9]+|-) "(?&lt;referrer&gt;http://www\.yoursite\.com[^"]*)"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>"(?:GET|POST) (?P&lt;file&gt;[^#? "]+)(?:[#?][^ "]*)? HTTP/[0-9.]+" 40=
4 (?:[0-9]+|-) "(?P&lt;referrer&gt;http://www\.yoursite\.com[^"]*)"</pre>
<p>Regex options: None<br>
Regex flavors: PCRE 4,
        Perl 5.10, Python</p>
<pre>"(?:GET|POST) ([^#? "]+)(?:[#?][^ "]*)? HTTP/[0-9.]+" 404 (?:[0-9]+|-)=
 "(http://www\.yoursite\.com[^"]*)"</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>^(?&lt;client&gt;\S+) \S+ (?&lt;userid&gt;\S+) \[(?&lt;datetime&gt;[^\=
]]+)\] "(?&lt;method&gt;[A-Z]+) (?&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?&=
lt;status&gt;404) (?&lt;size&gt;[0-9]+|-) "(?&lt;referrer&gt;http://www\.yo=
ursite\.com[^"]*)" "(?&lt;useragent&gt;[^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>^(?&lt;client&gt;\S+) \S+ (?&lt;userid&gt;\S+) \[(?&lt;datetime&gt;[^\=
]]+)\] "(?&lt;method&gt;[A-Z]+) (?&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?&=
lt;status&gt;404) (?&lt;size&gt;[0-9]+|-) "(?&lt;referrer&gt;http://www\.yo=
ursite\.com[^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>"(?&lt;method&gt;GET|POST) (?&lt;request&gt;[^ "]+)? HTTP/[0-9.]+" (?&=
lt;status&gt;404) (?&lt;size&gt;[0-9]+|-) "(?&lt;referrer&gt;http://www\.yo=
ursite\.com[^"]*)"</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java 7, XRegExp, PCRE 7, Perl 5.10, Ruby 1.9</p>
<h1>8. URLs, Paths, and Internet Addresses</h1>
<h2>8.1. Validating URLs</h2>
<h3>Solution</h3>
<pre>^(https?|ftp|file)://.+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A(https?|ftp|file)://.+\Z</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\A                         # Anchor
(https?|ftp)://            # Scheme
[a-z0-9-]+(\.[a-z0-9-]+)+  # Domain
([/?].*)?                  # Path and/or parameters
\Z                         # Anchor</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^(https?|ftp)://[a-z0-9-]+(\.[a-z0-9-]+)+([/?].+)?$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A                             # Anchor
((https?|ftp)://|(www|ftp)\.)  # Scheme or subdomain
[a-z0-9-]+(\.[a-z0-9-]+)+      # Domain
([/?].*)?                      # Path and/or parameters
\Z                             # Anchor</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^((https?|ftp)://|(www|ftp)\.)[a-z0-9-]+(\.[a-z0-9-]+)+([/?].*)?$</pre=
>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A                         # Anchor
(https?|ftp)://            # Scheme
[a-z0-9-]+(\.[a-z0-9-]+)+  # Domain
(/[\w-]+)*                 # Path
/[\w-]+\.(gif|png|jpg)     # File
\Z                         # Anchor</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^(https?|ftp)://[a-z0-9-]+(\.[a-z0-9-]+)+(/[\w-]+)*/[\w-]+\.(gif|png|j=
pg)$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.2. Finding URLs Within Full Text</h2>
<h3>Solution</h3>
<pre>\b(https?|ftp|file)://\S+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(https?|ftp|file)://[-A-Z0-9+&amp;@#/%?=3D~_|$!:,.;]*[A-Z0-9+&amp;@#=
/%=3D~_|$]</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b((https?|ftp|file)://|(www|ftp)\.)[-A-Z0-9+&amp;@#/%?=3D~_|$!:,.;]*[=
A-Z0-9+&amp;@#/%=3D~_|$]</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.3. Finding Quoted URLs in Full Text</h2>
<h3>Solution</h3>
<pre>\b(?:(?:https?|ftp|file)://|(www|ftp)\.)[-A-Z0-9+&amp;@#/%?=3D~_|$!:,.=
;]*
                                        [-A-Z0-9+&amp;@#/%=3D~_|$]
|"(?:(?:https?|ftp|file)://|(www|ftp)\.)[^"\r\n]+"
|'(?:(?:https?|ftp|file)://|(www|ftp)\.)[^'\r\n]+'</pre>
<p>Regex options: Free-spacing, case insensitive, dot matches line breaks, =
anchors match
        at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.4. Finding URLs with Parentheses in Full Text</h2>
<h3>Solution</h3>
<pre>\b(?:(?:https?|ftp|file)://|www\.|ftp\.)
  (?:\([-A-Z0-9+&amp;@#/%=3D~_|$?!:,.]*\)|[-A-Z0-9+&amp;@#/%=3D~_|$?!:,.])*
  (?:\([-A-Z0-9+&amp;@#/%=3D~_|$?!:,.]*\)|[A-Z0-9+&amp;@#/%=3D~_|$])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:(?:https?|ftp|file)://|www\.|ftp\.)(?:\([-A-Z0-9+&amp;@#/%=3D~_|$=
?!:,.]*\)|[-A-Z0-9+&amp;@#/%=3D~_|$?!:,.])*(?:\([-A-Z0-9+&amp;@#/%=3D~_|$?!=
:,.]*\)|[A-Z0-9+&amp;@#/%=3D~_|$])</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>http://en.wikipedia.org/wiki/PC_Tools_(Central_Point_Software)
http://msdn.microsoft.com/en-us/library/aa752574(VS.85).aspx</pre>
<pre>RegexBuddy's website (at http://www.regexbuddy.com) is really cool.</p=
re>
<pre>[-A-Z0-9+&amp;@#/%=3D~_|$?!:,.]</pre>
<pre>\([-A-Z0-9+&amp;@#/%=3D~_|$?!:,.]*\)|[-A-Z0-9+&amp;@#/%=3D~_|$?!:,.]</=
pre>
<pre>[A-Z0-9+&amp;@#/%=3D~_|$]</pre>
<pre>\([-A-Z0-9+&amp;@#/%=3D~_|$?!:,.]*\)|[A-Z0-9+&amp;@#/%=3D~_|$]</pre>
<h2>8.5. Turn URLs into Links</h2>
<h3>Solution</h3>
<pre>&lt;a href=3D"$&amp;"&gt;$&amp;&lt;/a&gt;</pre>
<pre>&lt;a href=3D"$0"&gt;$0&lt;/a&gt;</pre>
<pre>&lt;a href=3D"\0"&gt;\0&lt;/a&gt;</pre>
<pre>&lt;a href=3D"\&amp;"&gt;\&amp;&lt;/a&gt;</pre>
<pre>&lt;a href=3D"\g&lt;0&gt;"&gt;\g&lt;0&gt;&lt;/a&gt;</pre>
<h2>8.6. Validating URNs</h2>
<h3>Solution</h3>
<pre>\Aurn:
# Namespace Identifier
[a-z0-9][a-z0-9-]{0,31}:
# Namespace Specific String
[a-z0-9()+,\-.:=3D@;$_!*'%/?#]+
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^urn:[a-z0-9][a-z0-9-]{0,31}:[a-z0-9()+,\-.:=3D@;$_!*'%/?#]+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\burn:
# Namespace Identifier
[a-z0-9][a-z0-9-]{0,31}:
# Namespace Specific String
[a-z0-9()+,\-.:=3D@;$_!*'%/?#]+</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\burn:[a-z0-9][a-z0-9-]{0,31}:[a-z0-9()+,\-.:=3D@;$_!*'%/?#]+</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\burn:
# Namespace Identifier
[a-z0-9][a-z0-9-]{0,31}:
# Namespace Specific String
[a-z0-9()+,\-.:=3D@;$_!*'%/?#]*[a-z0-9+=3D@$/]</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\burn:[a-z0-9][a-z0-9-]{0,31}:[a-z0-9()+,\-.:=3D@;$_!*'%/?#]*[a-z0-9+=
=3D@$/]</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>The URN is urn:nid:nss, isn't it?</pre>
<h2>8.7. Validating Generic URLs</h2>
<h3>Solution</h3>
<pre>\A
(# Scheme
 [a-z][a-z0-9+\-.]*:
 (# Authority &amp; path
  //
  ([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?              # User
  ([a-z0-9\-._~%]+                            # Named host
  |\[[a-f0-9:.]+\]                            # IPv6 host
  |\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])  # IPvFuture host
  (:[0-9]+)?                                  # Port
  (/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?          # Path
 |# Path without authority
  (/?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+=
)*/?)?
 )
|# Relative URL (no scheme or authority)
 (# Relative path
  [a-z0-9\-._~%!$&amp;'()*+,;=3D@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?
 |# Absolute path
  (/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)+/?
 )
)
# Query
(\?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?
# Fragment
(\#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\A
(# Scheme
 (?&lt;scheme&gt;[a-z][a-z0-9+\-.]*):
 (# Authority &amp; path
  //
  (?&lt;user&gt;[a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?              # User
  (?&lt;host&gt;[a-z0-9\-._~%]+                            # Named host
  |       \[[a-f0-9:.]+\]                            # IPv6 host
  |       \[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])  # IPvFuture host
  (?&lt;port&gt;:[0-9]+)?                                  # Port
  (?&lt;path&gt;(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?)        # Path
 |# Path without authority
  (?&lt;path&gt;/?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+
          (/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?)?
 )
|# Relative URL (no scheme or authority)
 (?&lt;path&gt;
  # Relative path
  [a-z0-9\-._~%!$&amp;'()*+,;=3D@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?
 |# Absolute path
  (/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)+/?
 )
)
# Query
(?&lt;query&gt;\?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?
# Fragment
(?&lt;fragment&gt;\#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Perl 5.10, Ruby 1.9</p>
<pre>\A
(# Scheme
 (?&lt;scheme&gt;[a-z][a-z0-9+\-.]*):
 (# Authority &amp; path
  //
  (?&lt;user&gt;[a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?              # User
  (?&lt;host&gt;[a-z0-9\-._~%]+                            # Named host
  |       \[[a-f0-9:.]+\]                            # IPv6 host
  |       \[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])  # IPvFuture host
  (?&lt;port&gt;:[0-9]+)?                                  # Port
  (?&lt;hostpath&gt;(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?)    # Path
 |# Path without authority
  (?&lt;schemepath&gt;/?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+
                (/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?)?
 )
|# Relative URL (no scheme or authority)
 (?&lt;relpath&gt;
  # Relative path
  [a-z0-9\-._~%!$&amp;'()*+,;=3D@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?
 |# Absolute path
  (/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)+/?
 )
)
# Query
(?&lt;query&gt;\?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?
# Fragment
(?&lt;fragment&gt;\#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
(# Scheme
 (?P&lt;scheme&gt;[a-z][a-z0-9+\-.]*):
 (# Authority &amp; path
  //
  (?P&lt;user&gt;[a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?              # User
  (?P&lt;host&gt;[a-z0-9\-._~%]+                            # Named host
  |       \[[a-f0-9:.]+\]                             # IPv6 host
  |       \[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])   # IPvFuture hos=
t
  (?P&lt;port&gt;:[0-9]+)?                                  # Port
  (?P&lt;hostpath&gt;(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?)    # Path
 |# Path without authority
  (?P&lt;schemepath&gt;/?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+
                 (/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?)?
 )
|# Relative URL (no scheme or authority)
 (?P&lt;relpath&gt;
  # Relative path
  [a-z0-9\-._~%!$&amp;'()*+,;=3D@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?
 |# Absolute path
  (/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)+/?
 )
)
# Query
(?P&lt;query&gt;\?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?
# Fragment
(?P&lt;fragment&gt;\#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
        and later, Perl 5.10, Python</p>
<pre>^([a-z][a-z0-9+\-.]*:(\/\/([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?([a-z0-9=
\-._~%]+|\[[a-f0-9:.]+\]|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])(:[=
0-9]+)?(\/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*\/?|(\/?[a-z0-9\-._~%!$&amp;'=
()*+,;=3D:@]+(\/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*\/?)?)|([a-z0-9\-._~%!$=
&amp;'()*+,;=3D@]+(\/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*\/?|(\/[a-z0-9\-._=
~%!$&amp;'()*+,;=3D:@]+)+\/?))
(\?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@\/?]*)?(#[a-z0-9\-._~%!$&amp;'()*+,;=3D:=
@\/?]*)?$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.8. Extracting the Scheme from a URL</h2>
<h3>Solution</h3>
<h4>Extract the scheme from a URL known to be valid</h4>
<pre>^([a-z][a-z0-9+\-.]*):</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Extract the scheme while validating the URL</h4>
<pre>\A
([a-z][a-z0-9+\-.]*):
(# Authority &amp; path
 //
 ([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?              # User
 ([a-z0-9\-._~%]+                            # Named host
 |\[[a-f0-9:.]+\]                            # IPv6 host
 |\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])  # IPvFuture host
 (:[0-9]+)?                                  # Port
 (/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?          # Path
|# Path without authority
 (/?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)=
*/?)?
)
# Query
(\?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?
# Fragment
(\#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?
\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z][a-z0-9+\-.]*):(//([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?([a-z0-9\=
-._~%]+|\[[a-f0-9:.]+\]|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])(:[0=
-9]+)?(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?|(/?[a-z0-9\-._~%!$&amp;'()*+=
,;=3D:@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?)?)(\?[a-z0-9\-._~%!$&amp;=
'()*+,;=3D:@/?]*)?(#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.9. Extracting the User from a URL</h2>
<h3>Solution</h3>
<h4>Extract the user from a URL known to be valid</h4>
<pre>^[a-z0-9+\-.]+://([a-z0-9\-._~%!$&amp;'()*+,;=3D]+)@</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Extract the user while validating the URL</h4>
<pre>\A
[a-z][a-z0-9+\-.]*://                       # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=3D]+)@               # User
([a-z0-9\-._~%]+                            # Named host
|\[[a-f0-9:.]+\]                            # IPv6 host
|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])  # IPvFuture host
(:[0-9]+)?                                  # Port
(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?          # Path
(\?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?         # Query
(\#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?         # Fragment
\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^[a-z][a-z0-9+\-.]*://([a-z0-9\-._~%!$&amp;'()*+,;=3D]+)@([a-z0-9\-._~=
%]+|\[[a-f0-9:.]+\]|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])(:[0-9]+=
)?(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?(\?[a-z0-9\-._~%!$&amp;'()*+,;=3D=
:@/?]*)?(#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.10. Extracting the Host from a URL</h2>
<h3>Solution</h3>
<h4>Extract the host from a URL known to be valid</h4>
<pre>\A
[a-z][a-z0-9+\-.]*://               # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?      # User
([a-z0-9\-._~%]+                    # Named or IPv4 host
|\[[a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])   # IPv6+ host</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^[a-z][a-z0-9+\-.]*://([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?([a-z0-9\-._=
~%]+|\[[a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Extract the host while validating the URL</h4>
<pre>\A
[a-z][a-z0-9+\-.]*://                       # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?              # User
([a-z0-9\-._~%]+                            # Named host
|\[[a-f0-9:.]+\]                            # IPv6 host
|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])  # IPvFuture host
(:[0-9]+)?                                  # Port
(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?          # Path
(\?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?         # Query
(\#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?         # Fragment
\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^[a-z][a-z0-9+\-.]*://([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?([a-z0-9\-._=
~%]+|\[[a-f0-9:.]+\]|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])(:[0-9]=
+)?(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?(\?[a-z0-9\-._~%!$&amp;'()*+,;=
=3D:@/?]*)?(#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.11. Extracting the Port from a URL</h2>
<h3>Solution</h3>
<h4>Extract the port from a URL known to be valid</h4>
<pre>\A
[a-z][a-z0-9+\-.]*://               # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?      # User
([a-z0-9\-._~%]+                    # Named or IPv4 host
|\[[a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])   # IPv6+ host
:(?&lt;port&gt;[0-9]+)                    # Port number</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
[a-z][a-z0-9+\-.]*://               # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?      # User
([a-z0-9\-._~%]+                    # Named or IPv4 host
|\[[a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])   # IPv6+ host
:(?P&lt;port&gt;[0-9]+)                   # Port number</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE,
          Perl 5.10, Python</p>
<pre>^[a-z][a-z0-9+\-.]*://([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?([a-z0-9\-._=
~%]+|\[[a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\]):([0-9]+)</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Extract the port while validating the URL</h4>
<pre>\A
[a-z][a-z0-9+\-.]*://                       # Scheme
([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?              # User
([a-z0-9\-._~%]+                            # Named host
|\[[a-f0-9:.]+\]                            # IPv6 host
|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\])  # IPvFuture host
:([0-9]+)                                   # Port
(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?          # Path
(\?[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?         # Query
(\#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@/?]*)?         # Fragment
\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^[a-z][a-z0-9+\-.]*:\/\/([a-z0-9\-._~%!$&amp;'()*+,;=3D]+@)?([a-z0-9\-=
._~%]+|\[[a-f0-9:.]+\]|\[v[a-f0-9][a-z0-9\-._~%!$&amp;'()*+,;=3D:]+\]):([0-=
9]+)(\/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*\/?(\?[a-z0-9\-._~%!$&amp;'()*+,=
;=3D:@\/?]*)?(#[a-z0-9\-._~%!$&amp;'()*+,;=3D:@\/?]*)?$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.12. Extracting the Path from a URL</h2>
<h3>Solution</h3>
<pre>\A
# Skip over scheme and authority, if any
([a-z][a-z0-9+\-.]*:(//[^/?#]+)?)?
# Path
([a-z0-9\-._~%!$&amp;'()*+,;=3D:@/]*)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z][a-z0-9+\-.]*:(//[^/?#]+)?)?([a-z0-9\-._~%!$&amp;'()*+,;=3D:@/]=
*)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A
# Skip over scheme and authority, if any
([a-z][a-z0-9+\-.]*:(//[^/?#]+)?)?
# Path
(/?[a-z0-9\-._~%!$&amp;'()*+,;=3D@]+(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/=
?|/)
# Query, fragment, or end of URL
([#?]|\Z)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z][a-z0-9+\-.]*:(//[^/?#]+)?)?(/?[a-z0-9\-._~%!$&amp;'()*+,;=3D@]=
+(/[a-z0-9\-._~%!$&amp;'()*+,;=3D:@]+)*/?|/)([#?]|$)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\A
# Skip over scheme and authority, if any
(?&gt;([a-z][a-z0-9+\-.]*:(//[^/?#]+)?)?)
# Path
([a-z0-9\-._~%!$&amp;'()*+,;=3D:@/]+)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Ruby</p>
<h2>8.13. Extracting the Query from a URL</h2>
<h3>Solution</h3>
<pre>^[^?#]+\?([^#]+)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.14. Extracting the Fragment from a URL</h2>
<h3>Solution</h3>
<pre>#(.+)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.15. Validating Domain Names</h2>
<h3>Solution</h3>
<pre>^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}\Z</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, PCRE, Perl, Python, Ruby</p>
<pre>\b([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b((?=3D[a-z0-9-]{1,63}\.)[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,63}\b</pre=
>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b((xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b((?=3D[a-z0-9-]{1,63}\.)(xn--)?[a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,63}=
\b</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.16. Matching IPv4 Addresses</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-=
9]|[01]?[0-9][0-9]?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[=
0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0=
-9]|[01]?[0-9][0-9]?)\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2=
[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-=
9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01=
]?[0-9][0-9]?)$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1=
[0-9][0-9]|[1-9]?[0-9])\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.(25=
[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Perl</h4>
<pre>if ($subject =3D~ m/^([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{=
1,3})/)
{
    $ip =3D $1 &lt;&lt; 24 | $2 &lt;&lt; 16 | $3 &lt;&lt; 8 | $4;
}</pre>
<h2>8.17. Matching IPv6 Addresses</h2>
<h3>Solution</h3>
<h4>Standard notation</h4>
<pre>^(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}\Z</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>(?&lt;![:.\w])(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}(?![:.\w])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>\b(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Mixed notation</h4>
<pre>^(?:[A-F0-9]{1,4}:){6}(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9=
])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>(?&lt;![:.\w])(?:[A-F0-9]{1,4}:){6}(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-=
9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(?![:.\=
w])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:[A-F0-9]{1,4}:){6}(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-=
9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Standard or mixed notation</h4>
<pre>\A                                                       # Start of st=
ring
(?:[A-F0-9]{1,4}:){6}                                        # 6 words
(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}                               # 2 words
|  (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # or 4 bytes
   (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
)\Z                                                      # End of string</p=
re>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:[A-F0-9]{1,4}:){6}(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}|(?:(?:25[0-5]|2[0=
-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[=
1-9]?[0-9]))$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>(?&lt;![:.\w])                                              # Anchor a=
ddress
(?:[A-F0-9]{1,4}:){6}                                        # 6 words
(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}                               # 2 words
|  (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # or 4 bytes
   (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
)(?![:.\w])                                              # Anchor address</=
pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>\b                                                       # Word bounda=
ry
(?:[A-F0-9]{1,4}:){6}                                        # 6 words
(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}                               # 2 words
|  (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}  # or 4 bytes
   (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
)\b                                                      # Word boundary</p=
re>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>\b(?:[A-F0-9]{1,4}:){6}(?:[A-F0-9]{1,4}:[A-F0-9]{1,4}|(?:(?:25[0-5]|2[=
0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|=
[1-9]?[0-9]))\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Compressed notation</h4>
<pre>\A(?:
 # Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
 # Compressed with at most 7 colons
|(?=3D(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    \Z) # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}|(?=3D(?:[A-F0-9]{0,4}:){0,7}[A-=
F0-9]{0,4}$)(([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)|(?:[A-F0-9]{=
1,4}:){7}:|:(:[A-F0-9]{1,4}){7})$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>(?&lt;![:.\w])(?:
 # Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
 # Compressed with at most 7 colons
|(?=3D(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    (?![:.\w])) # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>(?:
 # Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
 # Compressed with at most 7 colons
|(?=3D(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    (?![:.\w])) # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>(?:(?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}|(?=3D(?:[A-F0-9]{0,4}:){0,7}[A-F=
0-9]{0,4}(?![:.\w]))(([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)|(?:[=
A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7})(?![:.\w])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Compressed mixed notation</h4>
<pre>\A
(?:
 # Non-compressed
 (?:[A-F0-9]{1,4}:){6}
 # Compressed with at most 6 colons
|(?=3D(?:[A-F0-9]{0,4}:){0,6}
    (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
    \Z)                            # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
 # Compressed with 7 colons and 5 numbers
|::(?:[A-F0-9]{1,4}:){5}
)
# 255.255.255.
(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
# 255
(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:[A-F0-9]{1,4}:){6}|(?=3D(?:[A-F0-9]{0,4}:){0,6}(?:[0-9]{1,3}\.)=
{3}[0-9]{1,3}$)(([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)|::(?:[A-=
F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(?:=
25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>(?&lt;![:.\w])
(?:
 # Non-compressed
 (?:[A-F0-9]{1,4}:){6}
 # Compressed with at most 6 colons
|(?=3D(?:[A-F0-9]{0,4}:){0,6}
    (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
    (?![:.\w]))                    # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
 # Compressed with 7 colons and 5 numbers
|::(?:[A-F0-9]{1,4}:){5}
)
# 255.255.255.
(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
# 255
(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>(?:
 # Non-compressed
 (?:[A-F0-9]{1,4}:){6}
 # Compressed with at most 6 colons
|(?=3D(?:[A-F0-9]{0,4}:){0,6}
    (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
    (?![:.\w]))                    # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
 # Compressed with 7 colons and 5 numbers
|::(?:[A-F0-9]{1,4}:){5}
)
# 255.255.255.
(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
# 255
(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>(?:(?:[A-F0-9]{1,4}:){6}|(?=3D(?:[A-F0-9]{0,4}:){0,6}(?:[0-9]{1,3}\.){=
3}[0-9]{1,3}(?![:.\w]))(([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)|=
::(?:[A-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\=
.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(?![:.\w])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Standard, mixed, or compressed notation</h4>
<pre>\A(?:
# Mixed
 (?:
  # Non-compressed
  (?:[A-F0-9]{1,4}:){6}
  # Compressed with at most 6 colons
 |(?=3D(?:[A-F0-9]{0,4}:){0,6}
     (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
     \Z)                            # and anchored
  # and at most 1 double colon
  (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
  # Compressed with 7 colons and 5 numbers
 |::(?:[A-F0-9]{1,4}:){5}
 )
 # 255.255.255.
 (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
 # 255
 (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
|# Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
|# Compressed with at most 7 colons
 (?=3D(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    \Z)  # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:(?:[A-F0-9]{1,4}:){6}|(?=3D(?:[A-F0-9]{0,4}:){0,6}(?:[0-9]{1,3}=
\.){3}[0-9]{1,3}$)(([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)|::(?:=
[A-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}=
(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])|(?:[A-F0-9]{1,4}:){7}[A-F0-=
9]{1,4}|(?=3D(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}$)(([0-9A-F]{1,4}:){1,7}|:=
)((:[0-9A-F]{1,4}){1,7}|:)|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7})$</p=
re>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>(?&lt;![:.\w])(?:
# Mixed
 (?:
  # Non-compressed
  (?:[A-F0-9]{1,4}:){6}
  # Compressed with at most 6 colons
 |(?=3D(?:[A-F0-9]{0,4}:){0,6}
     (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
     (?![:.\w]))                    # and anchored
  # and at most 1 double colon
  (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
  # Compressed with 7 colons and 5 numbers
 |::(?:[A-F0-9]{1,4}:){5}
 )
 # 255.255.255.
 (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
 # 255
 (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
|# Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
|# Compressed with at most 7 colons
 (?=3D(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    (?![:.\w]))  # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby 1.9</p>
<pre>(?:
 # Mixed
 (?:
  # Non-compressed
  (?:[A-F0-9]{1,4}:){6}
  # Compressed with at most 6 colons
 |(?=3D(?:[A-F0-9]{0,4}:){0,6}
     (?:[0-9]{1,3}\.){3}[0-9]{1,3}  # and 4 bytes
     (?![:.\w]))                    # and anchored
  # and at most 1 double colon
  (([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|:)
  # Compressed with 7 colons and 5 numbers
 |::(?:[A-F0-9]{1,4}:){5}
 )
 # 255.255.255.
 (?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}
 # 255
 (?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])
|# Standard
 (?:[A-F0-9]{1,4}:){7}[A-F0-9]{1,4}
|# Compressed with at most 7 colons
 (?=3D(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}
    (?![:.\w]))  # and anchored
 # and at most 1 double colon
 (([0-9A-F]{1,4}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)
 # Compressed with 8 colons
|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4}){7}
)(?![:.\w])</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>(?:(?:(?:[A-F0-9]{1,4}:){6}|(?=3D(?:[A-F0-9]{0,4}:){0,6}(?:[0-9]{1,3}\=
.){3}[0-9]{1,3}(?![:.\w]))(([0-9A-F]{1,4}:){0,5}|:)((:[0-9A-F]{1,4}){1,5}:|=
:)|::(?:[A-F0-9]{1,4}:){5})(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9=
])\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)|(?:[A-F0-9]{1,4}:){7}[A-F0=
-9]{1,4}|(?=3D(?:[A-F0-9]{0,4}:){0,7}[A-F0-9]{0,4}(?![:.\w]))(([0-9A-F]{1,4=
}:){1,7}|:)((:[0-9A-F]{1,4}){1,7}|:)|(?:[A-F0-9]{1,4}:){7}:|:(:[A-F0-9]{1,4=
}){7})(?![:.\w])</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<h4>Compressed notation</h4>
<pre>(
  ([0-9A-F]{1,4}:){1,7}  # 1 to 7 words to the left
| :                      # or a double colon at the start
)
(
  (:[0-9A-F]{1,4}){1,7}  # 1 to 7 words to the right
| :                      # or a double colon at the end
)</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>\A(?:a{7}x
 |  a{6}xb?
 |  a{5}xb{0,2}
 |  a{4}xb{0,3}
 |  a{3}xb{0,4}
 |  a{2}xb{0,5}
 |  axb{0,6}
 |  xb{0,7}
)\Z</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>\A
  (?=3D[abx]{1,8}\Z)
  a{0,7}xb{0,7}
\Z</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<h4>Standard, mixed, or compressed notation</h4>
<pre>^(6words|compressed6words)ip4$</pre>
<pre>^(8words|compressed8words)$</pre>
<pre>^((6words|compressed6words)ip4|8words|compressed8words)$</pre>
<pre>^((6words|compressed6words)ip4|(8words|compressed8words))$</pre>
<h2>8.18. Validate Windows Paths</h2>
<h3>Solution</h3>
<h4>Drive letter paths</h4>
<pre>\A
[a-z]:\\                    # Drive
(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*   # Folder
[^\\/:*?"&lt;&gt;|\r\n]*          # File
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^[a-z]:\\(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*[^\\/:*?"&lt;&gt;|\r\n]*$</pre=
>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h4>Drive letter and UNC paths</h4>
<pre>\A
(?:[a-z]:|\\\\[a-z0-9_.$\ -]+\\[a-z0-9_.$\ -]+)\\  =E2=80=89# Drive
(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*                          =E2=80=88=E2=80=89=
# Folder
[^\\/:*?"&lt;&gt;|\r\n]*                                 =E2=80=88=E2=80=89=
# File
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\(?:[^\\/:*?"&lt;&gt;|\=
r\n]+\\)*[^\\/:*?"&lt;&gt;|\r\n]*$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h4>Drive letter, UNC, and relative paths</h4>
<pre>\A
(?:(?:[a-z]:|\\\\[a-z0-9_.$\ -]+\\[a-z0-9_.$\ -]+)\\|  # Drive
   \\?[^\\/:*?"&lt;&gt;|\r\n]+\\?)                           =E2=80=89# Rel=
ative path
(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*                              =E2=80=89# Fol=
der
[^\\/:*?"&lt;&gt;|\r\n]*                                     =E2=80=89# Fil=
e
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:(?:[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\|\\?[^\\/:*?"&lt;&g=
t;|\r\n]+\\?)(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*[^\\/:*?"&lt;&gt;|\r\n]*$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h2>8.19. Split Windows Paths into Their Parts</h2>
<h3>Solution</h3>
<h4>Drive letter paths</h4>
<pre>\A
(?&lt;drive&gt;[a-z]:)\\
(?&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
(?P&lt;drive&gt;[a-z]:)\\
(?P&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?P&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<pre>\A
([a-z]:)\\
((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
([^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z]:)\\((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)([^\\/:*?"&lt;&gt;|\r\n]*)=
$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h4>Drive letter and UNC paths</h4>
<pre>\A
(?&lt;drive&gt;[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
(?&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
(?P&lt;drive&gt;[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
(?P&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?P&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<pre>\A
([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
([^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\((?:[^\\/:*?"&lt;&gt;|\r=
\n]+\\)*)([^\\/:*?"&lt;&gt;|\r\n]*)$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h4>Drive letter, UNC, and relative paths</h4>
<pre>\A
(?&lt;drive&gt;[a-z]:\\|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+\\|\\?)
(?&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
(?P&lt;drive&gt;[a-z]:\\|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+\\|\\?)
(?P&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
(?P&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<pre>\A
([a-z]:\\|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+\\|\\?)
((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
([^\\/:*?"&lt;&gt;|\r\n]*)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^([a-z]:\\|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+\\|\\?)((?:[^\\/:*?"&lt;&=
gt;|\r\n]+\\)*)([^\\/:*?"&lt;&gt;|\r\n]*)$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<h3>Discussion</h3>
<h4>Drive letter, UNC, and relative paths</h4>
<pre>\A
(?:
   (?&lt;drive&gt;[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
   (?&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
   (?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?&lt;relativefolder&gt;\\?(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)
   (?&lt;file2&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?&lt;relativefile&gt;[^\\/:*?"&lt;&gt;|\r\n]+)
)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java 7, PCRE 7, Perl 5.10, Ruby 1.9</p>
<pre>\A
(?:
   (?P&lt;drive&gt;[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
   (?P&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
   (?P&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?P&lt;relativefolder&gt;\\?(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)
   (?P&lt;file2&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?P&lt;relativefile&gt;[^\\/:*?"&lt;&gt;|\r\n]+)
)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: PCRE 4
          and later, Perl 5.10, Python</p>
<pre>\A
(?:
   ([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
   ((?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
   ([^\\/:*?"&lt;&gt;|\r\n]*)
|  (\\?(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)
   ([^\\/:*?"&lt;&gt;|\r\n]*)
|  ([^\\/:*?"&lt;&gt;|\r\n]+)
)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Python, Ruby</p>
<pre>^(?:([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\((?:[^\\/:*?"&lt;&gt;=
|\r\n]+\\)*)([^\\/:*?"&lt;&gt;|\r\n]*)|(\\?(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)=
([^\\/:*?"&lt;&gt;|\r\n]*)|([^\\/:*?"&lt;&gt;|\r\n]+))$</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python</p>
<pre>\A
(?:
   (?&lt;drive&gt;[a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)\\
   (?&lt;folder&gt;(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)*)
   (?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?&lt;folder&gt;\\?(?:[^\\/:*?"&lt;&gt;|\r\n]+\\)+)
   (?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]*)
|  (?&lt;file&gt;[^\\/:*?"&lt;&gt;|\r\n]+)
)
\Z</pre>
<p>Regex options: Free-spacing, case insensitive<br>
Regex flavors: .NET,
          Perl 5.10, Ruby 1.9</p>
<h2>8.20. Extract the Drive Letter from a Windows Path</h2>
<h3>Solution</h3>
<pre>^([a-z]):</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.21. Extract the Server and Share from a UNC Path</h2>
<h3>Solution</h3>
<pre>^\\\\([a-z0-9_.$ -]+)\\([a-z0-9_.$ -]+)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.22. Extract the Folder from a Windows Path</h2>
<h3>Solution</h3>
<pre>^([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)?((?:\\|^)(?:[^\\/:*?"&lt;=
&gt;|\r\n]+\\)+)</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>^([a-z]:|\\\\[a-z0-9_.$ -]+\\[a-z0-9_.$ -]+)?((?:\\?(?:[^\\/:*?"&lt;&g=
t;|\r\n]+\\)+)</pre>
<h2>8.23. Extract the Filename from a Windows Path</h2>
<h3>Solution</h3>
<pre>[^\\/:*?"&lt;&gt;|\r\n]+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.24. Extract the File Extension from a Windows Path</h2>
<h3>Solution</h3>
<pre>\.[^.\\/:*?"&lt;&gt;|\r\n]+$</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>8.25. Strip Invalid Characters from Filenames</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>[\\/:"*?&lt;&gt;|]+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h1>9. Markup and Data Formats</h1>
<h3>Basic Rules for Formats Covered in This Chapter</h3>
<pre>&lt;a href=3D"http://www.regexcookbook.com"
    title =3D 'Regex Cookbook'&gt;Click me!&lt;/a&gt;</pre>
<pre>&lt;!-- this is a comment --&gt;
&lt;!-- so is this, but this comment
    spans more than one line --&gt;</pre>
<pre>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd"&gt;</pre>
<pre>&lt;!DOCTYPE html&gt;</pre>
<pre>&lt;!DOCTYPE example [
  &lt;!ENTITY copy "&amp;#169;"&gt;
  &lt;!ENTITY copyright-notice "Copyright &amp;copy; 2012, O'Reilly"&gt;
]&gt;</pre>
<pre>aaa,b b,"""c"" cc"
1,,"333, three,
still more threes"</pre>
<pre>333, three,
still more threes</pre>
<pre>; last modified 2012-02-14

[user]
name=3DJ. Random Hacker

[post]
title =3D How do I love thee, regular expressions?
content =3D "Let me count the ways..."</pre>
<h2>9.1. Find XML-Style Tags</h2>
<h3>Solution</h3>
<h4>Quick and dirty</h4>
<pre>&lt;[^&gt;]*&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Allow &gt; in attribute values</h4>
<pre>&lt;(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(?: [^&gt;"']   # Non-quoted character
  | "[^"]*"  # Double-quoted attribute value
  | '[^']*'  # Single-quoted attribute value
)*
&gt;</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>(X)HTML tags (loose)</h4>
<pre>&lt;/?([A-Za-z][^\s&gt;/]*)(?:=3D\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&=
gt;])*(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
/?                  # Permit closing tags
([A-Za-z][^\s&gt;/]*)  # Capture the tag name to backreference 1
(?:                 # Attribute value branch:
  =3D \s*             #   Signals the start of an attribute value
  (?: "[^"]*"       #   Double-quoted attribute value
    | '[^']*'       #   Single-quoted attribute value
    | [^\s&gt;]+       #   Unquoted attribute value
  )
|                   # Non-attribute-value branch:
  [^&gt;]              #   Character outside of an attribute value
)*
(?:&gt;|$)             # End of the tag or string</pre>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>(X)HTML tags (strict)</h4>
<pre>&lt;(?:([A-Z][-:A-Z0-9]*)(?:\s+[A-Z][-:A-Z0-9]*(?:\s*=3D\s*(?:"[^"]*"|=
'[^']*'|[^"'`=3D&lt;&gt;\s]+))?)*\s*/?|/([A-Z][-:A-Z0-9]*)\s*)&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(?:                    # Branch for opening tags:
  ([A-Z][-:A-Z0-9]*)   #   Capture the opening tag name to backreference 1
  (?:                  #   This group permits zero or more attributes
    \s+                #   Whitespace to separate attributes
    [A-Z][-:A-Z0-9]*   #   Attribute name
    (?: \s*=3D\s*        #   Attribute name-value delimiter
      (?: "[^"]*"      #   Double-quoted attribute value
        | '[^']*'      #   Single-quoted attribute value
        | [^"'`=3D&lt;&gt;\s]+ #   Unquoted attribute value (HTML)
      )
    )?                 #   Permit attributes without a value (HTML)
  )*
  \s*                  #   Permit trailing whitespace
  /?                   #   Permit self-closed tags
|                      # Branch for closing tags:
  /
  ([A-Z][-:A-Z0-9]*)   #   Capture the closing tag name to backreference 2
  \s*                  #   Permit trailing whitespace
)
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>XML tags (strict)</h4>
<pre>&lt;(?:([_:A-Z][-.:\w]*)(?:\s+[_:A-Z][-.:\w]*\s*=3D\s*(?:"[^"]*"|'[^']=
*'))*\s*/?|/([_:A-Z][-.:\w]*)\s*)&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(?:                  # Branch for opening tags:
  ([_:A-Z][-.:\w]*)  #   Capture the opening tag name to backreference 1
  (?:                #   This group permits zero or more attributes
    \s+              #   Whitespace to separate attributes
    [_:A-Z][-.:\w]*  #   Attribute name
    \s*=3D\s*          #   Attribute name-value delimiter
    (?: "[^"]*"      #   Double-quoted attribute value
      | '[^']*'      #   Single-quoted attribute value
    )
  )*
  \s*                #   Permit trailing whitespace
  /?                 #   Permit self-closed tags
|                    # Branch for closing tags:
  /
  ([_:A-Z][-.:\w]*)  #   Capture the closing tag name to backreference 2
  \s*                #   Permit trailing whitespace
)
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<h4>Allow &gt; in attribute values</h4>
<pre>&lt;(?&gt;(?:(?&gt;[^&gt;"']+)|"[^"]*"|'[^']*')*)&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, PCRE, Perl, Ruby</p>
<pre>&lt;(?:[^&gt;"']++|"[^"]*"|'[^']*')*+&gt;</pre>
<p>Regex options: None<br>
Regex flavors: Java, PCRE, Perl 5.10, Ruby 1.9</p>
<h4>(X)HTML tags (loose)</h4>
<pre>&lt;([A-Za-z][^\s&gt;/]*)(?:=3D\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt=
;/])*(?:&gt;|$)</pre>
<pre>&lt;([A-Za-z][^\s&gt;/]*)(?:=3D\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt=
;])*(?:/&gt;|$)</pre>
<pre>&lt;([A-Za-z][^\s&gt;/]*)(?:=3D\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&gt=
;])*(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;/([A-Za-z][^\s&gt;/]*)(?:=3D\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^&g=
t;])*(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;/?([A-Za-z](?&gt;[^\s&gt;/]*))(?&gt;=3D\s*(?:"[^"]*"|'[^']*'|[^\s&=
gt;]+)|[^&gt;])*(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, PCRE, Perl, Ruby</p>
<pre>&lt;/?([A-Za-z][^\s&gt;/]*+)(?:=3D\s*(?:"[^"]*"|'[^']*'|[^\s&gt;]+)|[^=
&gt;])*+(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: Java, PCRE, Perl 5.10, Ruby 1.9</p>
<pre>&lt;/?([A-Za-z](?=3D([^\s&gt;/]*))\2)(?=3D((?:=3D\s*(?:"[^"]*"|'[^']*'=
|[^\s&gt;]+)|[^&gt;])*))\3(?:&gt;|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>(X)HTML tags (strict)</h4>
<pre>&lt;([A-Z][-:A-Z0-9]*)(?:\s+[A-Z][-:A-Z0-9]*(?:\s*=3D\s*(?:"[^"]*"|'[^=
']*'|[^"'`=3D&lt;&gt;\s]+))?)*\s*/?&gt;</pre>
<p>Regex options: Case insensitive<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;/([A-Z][-:A-Z0-9]*)\s*&gt;</pre>
<p>Regex options: Case insensitive<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>XML tags (strict)</h4>
<pre>&lt;([_:A-Z][-.:\w]*)(?:\s+[_:A-Z][-.:\w]*\s*=3D\s*(?:"[^"]*"|'[^']*')=
)*\s*/?&gt;</pre>
<p>Regex options: Case insensitive<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;/([_:A-Z][-.:\w]*)\s*&gt;</pre>
<p>Regex options: Case insensitive<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Skip Tricky (X)HTML and XML Sections</h3>
<h4>Outer regex for (X)HTML</h4>
<pre>&lt;!--.*?--&gt;|&lt;!\[CDATA\[.*?]]&gt;|&lt;(script|style|textarea|ti=
tle|xmp)\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;.*?&lt;/\1\s*&gt;|&lt;plaintext=
\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;.*</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre># Comment
&lt;!-- .*? --&gt;
|
# CDATA section
&lt;!\[CDATA\[ .*? ]]&gt;
|
# Special element and its content
&lt;( script | style | textarea | title | xmp )\b
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
&gt; .*? &lt;/\1\s*&gt;
|
# &lt;plaintext/&gt; continues until the end of the string
&lt;plaintext\b
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
&gt; .*</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;!--[\s\S]*?--&gt;|&lt;!\[CDATA\[[\s\S]*?]]&gt;|&lt;(script|style|t=
extarea|title|xmp)\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;[\s\S]*?&lt;/\1\s*&gt=
;|&lt;plaintext\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;[\s\S]*</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Outer regex for XML</h4>
<pre>&lt;!--.*?--\s*&gt;|&lt;!\[CDATA\[.*?]]&gt;|&lt;!DOCTYPE\s(?:[^&lt;&gt=
;"']|"[^"]*"|'[^']*'|&lt;!(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;)*&gt;</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre># Comment
&lt;!-- .*? --\s*&gt;
|
# CDATA section
&lt;!\[CDATA\[ .*? ]]&gt;
|
# Document type declaration
&lt;!DOCTYPE\s
    (?: [^&lt;&gt;"']  # Non-special character
      | "[^"]*"  # Double-quoted value
      | '[^']*'  # Single-quoted value
      | &lt;!(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;  # Markup declaration
    )*
&gt;</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;!--[\s\S]*?--\s*&gt;|&lt;!\[CDATA\[[\s\S]*?]]&gt;|&lt;!DOCTYPE\s(?=
:[^&lt;&gt;"']|"[^"]*"|'[^']*'|&lt;!(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;)*&gt=
;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>9.2. Replace &lt;b&gt; Tags with &lt;strong&gt;</h2>
<h3>Solution</h3>
<pre>&lt;(/?)b\b((?:[^&gt;"']|"[^"]*"|'[^']*')*)&gt;</pre>
<p>Regex options: Case
        insensitive<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(/?)             # Capture the optional leading slash to backreference 1
b \b             # Tag name, with word boundary
(                # Capture any attributes, etc. to backreference 2
    (?: [^&gt;"']   # Any character except &gt;, ", or '
      | "[^"]*"  # Double-quoted attribute value
      | '[^']*'  # Single-quoted attribute value
    )*
)
&gt;</pre>
<p>Regex options: Case
        insensitive, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;$1strong$2&gt;</pre>
<pre>&lt;\1strong\2&gt;</pre>
<pre>&lt;$1strong&gt;</pre>
<pre>&lt;\1strong&gt;</pre>
<h3>Variations</h3>
<h4>Replace a list of tags</h4>
<pre>&lt;(/?)([bi]|em|big)\b((?:[^&gt;"']|"[^"]*"|'[^']*')*)&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(/?)              # Capture the optional leading slash to backreference 1
([bi]|em|big) \b  # Capture the tag name to backreference 2
(                 # Capture any attributes, etc. to backreference 3
    (?: [^&gt;"']    # Any character except &gt;, ", or '
      | "[^"]*"   # Double-quoted attribute value
      | '[^']*'   # Single-quoted attribute value
    )*
)
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;$1strong$3&gt;</pre>
<pre>&lt;\1strong\3&gt;</pre>
<pre>&lt;$1strong&gt;</pre>
<pre>&lt;\1strong&gt;</pre>
<h2>9.3. Remove All XML-Style Tags Except &lt;em&gt; and
    &lt;strong&gt;</h2>
<h3>Solution</h3>
<h4>Solution 1: Match tags except &lt;em&gt; and
        &lt;strong&gt;</h4>
<pre>&lt;/?(?!(?:em|strong)\b)[a-z](?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt; /?                   # Permit closing tags
(?!
    (?: em | strong )  # List of tags to avoid matching
    \b                 # Word boundary avoids partial word matches
)
[a-z]                  # Tag name initial character must be a-z
(?: [^&gt;"']             # Any character except &gt;, ", or '
  | "[^"]*"            # Double-quoted attribute value
  | '[^']*'            # Single-quoted attribute value
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Solution 2: Match tags except &lt;em&gt; and &lt;strong&gt;,
        and any tags that contain attributes</h4>
<pre>&lt;/?(?!(?:em|strong)\s*&gt;)[a-z](?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;<=
/pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt; /?                   # Permit closing tags
(?!
    (?: em | strong )  # List of tags to avoid matching
    \s* &gt;              # Only avoid tags if they contain no attributes
)
[a-z]                  # Tag name initial character must be a-z
(?: [^&gt;"']             # Any character except &gt;, ", or '
  | "[^"]*"            # Double-quoted attribute value
  | '[^']*'            # Single-quoted attribute value
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<h4>Whitelist specific attributes</h4>
<pre>&lt;(?!(?:em|strong|a(?:\s+(?:href|title)\s*=3D\s*(?:"[^"]*"|'[^']*'))=
*)\s*&gt;)[a-z](?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt; /?          # Permit closing tags
(?!
  (?: em      # Dont match &lt;em&gt;
    | strong  #   or &lt;strong&gt;
    | a       #   or &lt;a&gt;
      (?:     # Only avoid matching &lt;a&gt; tags that use only
        \s+   #   href and/or title attributes
        (?:href|title)
        \s*=3D\s*
        (?:"[^"]*"|'[^']*')  # Quoted attribute value
      )*
  )
  \s* &gt;       # Only avoid matching these tags when they're
)             #   limited to any attributes permitted above
[a-z]         # Tag name initial character must be a-z
(?: [^&gt;"']    # Any character except &gt;, ", or '
  | "[^"]*"   # Double-quoted attribute value
  | '[^']*'   # Single-quoted attribute value
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h2>9.4. Match XML Names</h2>
<h3>Solution</h3>
<h4>XML 1.0 names (approximate)</h4>
<pre>^[:_\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nl}][:_\-.\p{L}\p{M}\p{Nd}\p{Nl}]*$</pr=
e>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<h4>XML 1.1 names (exact)</h4>
<pre>^[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\=
u1FFF\u200C\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0=
-\uFFFD][:_\-.A-Za-z0-9\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u036F\u0370-=
\u037D\u037F-\u1FFF\u200C\u200D\u203F\u2040\u2070-\u218F\u2C00-\u2FEF\u3001=
-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]*$</pre>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
Regex flavors: .NET,
          Java, JavaScript, Python, Ruby 1.9</p>
<pre>^[:_A-Za-z\x{C0}-\x{D6}\x{D8}-\x{F6}\x{F8}-\x{2FF}\x{370}-\x{37D}\x{37=
F}-\x{1FFF}\x{200C}\x{200D}\x{2070}-\x{218F}\x{2C00}-\x{2FEF}\x{3001}-\x{D7=
FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFFD}][:_\-.A-Za-z0-9\x{B7}\x{C0}-\x{D6}\x{=
D8}-\x{F6}\x{F8}-\x{36F}\x{370}-\x{37D}\x{37F}-\x{1FFF}\x{200C}\x{200D}\x{2=
03F}\x{2040}\x{2070}-\x{218F}\x{2C00}-\x{2FEF}\x{3001}-\x{D7FF}\x{F900}-\x{=
FDCF}\x{FDF0}-\x{FFFD}]*$</pre>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
Regex flavors: Java
          7, PCRE, Perl</p>
<h3>Discussion</h3>
<h4>XML 1.0 names</h4>
<pre>^                                   # Start of string
[:_\p{Ll}\p{Lu}\p{Lt}\p{Lo}\p{Nl}]  # Initial name character
[:_\-.\p{L}\p{M}\p{Nd}\p{Nl}]*      # Subsequent name characters (optional)
$                                   # End of string</pre>
<p>Regex options: Free-spacing (=E2=80=9C^ and $ match at line breaks=E2=80=
=9D must not be
          set)<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Ruby 1.9</p>
<pre>^[:_\p{L&amp;}\p{Lo}\p{Nl}][:_\-.\pL\pM\p{Nd}\p{Nl}]*$</pre>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
Regex flavors: PCRE,
          Perl</p>
<pre>^[:_\p{L}\p{Nl}-[\p{Lm}]][:_\-.\p{L}\p{M}\p{Nd}\p{Nl}]*$</pre>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
</p><pre>^[:_\pL\p{Nl}&amp;&amp;[^\p{Lm}]][:_\-.\pL\pM\p{Nd}\p{Nl}]*$</pre>
<p>Regex options: None
          (=E2=80=9C^ and $ match at line breaks=E2=80=9D must not be set)<=
br>
</p><h3>Variations</h3>
<pre>[^\d\s"'/&lt;=3D&gt;][^\s"'/&lt;=3D&gt;]*</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>(?!\d)[^\s"'/&lt;=3D&gt;]+</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>9.5. Convert Plain Text to HTML by Adding &lt;p&gt; and &lt;br&gt;
    Tags</h2>
<h3>Solution</h3>
<h4>Step 2: Replace all line breaks with &lt;br&gt;</h4>
<pre>\r\n?|\n</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>\R</pre>
<p>Regex options: None<br>
Regex flavors: PCRE
          7, Perl 5.10</p>
<pre>&lt;br&gt;</pre>
<h4>Step 3: Replace double &lt;br&gt; tags with
        &lt;/p&gt;&lt;p&gt;</h4>
<pre>&lt;br&gt;\s*&lt;br&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;/p&gt;&lt;p&gt;</pre>
<h4>Example JavaScript solution</h4>
<pre>function htmlFromPlainText(subject) {
    // Step 1 (plain text searches)
    subject =3D subject.replace(/&amp;/g, "&amp;amp;").
                      replace(/&lt;/g, "&amp;lt;").
                      replace(/&gt;/g, "&amp;gt;");

    // Step 2
    subject =3D subject.replace(/\r\n?|\n/g, "&lt;br&gt;");

    // Step 3
    subject =3D subject.replace(/&lt;br&gt;\s*&lt;br&gt;/g, "&lt;/p&gt;&lt;=
p&gt;");

    // Step 4
    subject =3D "&lt;p&gt;" + subject + "&lt;/p&gt;";

    return subject;
}

// Run some tests...
htmlFromPlainText("Test.");            // -&gt; "&lt;p&gt;Test.&lt;/p&gt;"
htmlFromPlainText("Test.\n");          // -&gt; "&lt;p&gt;Test.&lt;br&gt;&l=
t;/p&gt;"
htmlFromPlainText("Test.\n\n");        // -&gt; "&lt;p&gt;Test.&lt;/p&gt;&l=
t;p&gt;&lt;/p&gt;"
htmlFromPlainText("Test1.\nTest2.");   // -&gt; "&lt;p&gt;Test1.&lt;br&gt;T=
est2.&lt;/p&gt;"
htmlFromPlainText("Test1.\n\nTest2."); // -&gt; "&lt;p&gt;Test1.&lt;/p&gt;&=
lt;p&gt;Test2.&lt;/p&gt;"
htmlFromPlainText("&lt; AT&amp;T &gt;");         // -&gt; "&lt;p&gt;&amp;lt=
; AT&amp;amp;T &amp;gt;&lt;/p&gt;"</pre>
<h2>9.6. Decode XML Entities</h2>
<h3>Solution</h3>
<h4>Regular expression</h4>
<pre>&amp;(?:#([0-9]+)|#x([0-9a-fA-F]+)|([0-9a-zA-Z]+));</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Example JavaScript solution</h4>
<pre>// Accepts the match ($0) and backreferences; returns replacement text
function callback($0, $1, $2, $3) {
    var charCode;

    // Name lookup object that maps to decimal character codes
    // Equivalent hexadecimal numbers are listed in comments
    var names =3D {
        quot: 34, // 0x22
        amp: 38, // 0x26
        apos: 39, // 0x27
        lt: 60, // 0x3C
        gt: 62 // 0x3E
    };

    // Decimal character reference
    if ($1) {
        charCode =3D parseInt($1, 10);
    // Hexadecimal character reference
    } else if ($2) {
        charCode =3D parseInt($2, 16);
    // Named entity with a lookup mapping
    } else if ($3 &amp;&amp; ($3 in names)) {
        charCode =3D names[$3];
    // Invalid or unknown entity name
    } else {
        return $0; // Return the match unaltered
    }

    // Return a literal character
    return String.fromCharCode(charCode);
}

// Replace all entities with literal text
subject =3D subject.replace(
        /&amp;(?:#([0-9]+)|#x([0-9a-fA-F]+)|([0-9a-zA-Z]+));/g,
        callback);</pre>
<h3>Discussion</h3>
<pre>"&amp;lt; &amp;bogus; dec &amp;#65;&amp;#0065; &amp;amp;lt; hex &amp;#=
x41;&amp;#x041; &amp;gt;"</pre>
<pre>"&lt; &amp;bogus; dec AA &amp;lt; hex AA &gt;"</pre>
<h2>9.7. Find a Specific Attribute in XML-Style Tags</h2>
<h3>Solution</h3>
<h4>Tags that contain an id attribute (quick and dirty)</h4>
<pre>&lt;[^&gt;]+\sid\b[^&gt;]*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;         # Start of the tag
[^&gt;]+     # Tag name, attributes, etc.
\s id \b  # The target attribute name, as a whole word
[^&gt;]*     # The remainder of the tag, including the id attribute's value
&gt;         # End of the tag</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Tags that contain an id attribute (more reliable)</h4>
<pre>&lt;(?:[^&gt;"']|"[^"]*"|'[^']*')+?\sid\s*=3D\s*("[^"]*"|'[^']*')(?:[^=
&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(?: [^&gt;"']             # Tag and attribute names, etc.
  | "[^"]*"            #   and quoted attribute values
  | '[^']*'
)+?
\s id                  # The target attribute name, as a whole word
\s* =3D \s*              # Attribute name-value delimiter
( "[^"]*" | '[^']*' )  # Capture the attribute value to backreference 1
(?: [^&gt;"']             # Any remaining characters
  | "[^"]*"            #   and quoted attribute values
  | '[^']*'
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>&lt;div&gt; tags that contain an id attribute</h4>
<pre>&lt;div\s(?:[^&gt;"']|"[^"]*"|'[^']*')*?\bid\s*=3D\s*("[^"]*"|'[^']*')=
(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;div \s                # Tag name and following whitespace characte=
r
(?: [^&gt;"']             # Tag and attribute names, etc.
  | "[^"]*"            #   and quoted attribute values
  | '[^']*'
)*?
\b id                  # The target attribute name, as a whole word
\s* =3D \s*              # Attribute name-value delimiter
( "[^"]*" | '[^']*' )  # Capture the attribute value to backreference 1
(?: [^&gt;"']             # Any remaining characters
  | "[^"]*"            #   and quoted attribute values
  | '[^']*'
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Tags that contain an id attribute with the value
        =E2=80=9Cmy-id=E2=80=9D</h4>
<pre>&lt;(?:[^&gt;"']|"[^"]*"|'[^']*')+?\sid\s*=3D\s*(?:"my-id"|'my-id')(?:=
[^&gt;"']|"[^"]*"|'[^']*')*&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;
(?: [^&gt;"']     # Tag and attribute names, etc.
  | "[^"]*"    #   and quoted attribute values
  | '[^']*'
)+?
\s id          # The target attribute name, as a whole word
\s* =3D \s*      # Attribute name-value delimiter
(?: "my-id"    # The target attribute value
  | 'my-id' )  #   surrounded by single or double quotes
(?: [^&gt;"']     # Any remaining characters
  | "[^"]*"    #   and quoted attribute values
  | '[^']*'
)*
&gt;</pre>
<p>Regex options: Case
          insensitive, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Tags that contain =E2=80=9Cmy-class=E2=80=9D within their class attribu=
te
        value</h4>
<pre>&lt;(?:[^&gt;"']|"[^"]*"|'[^']*')+&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^(?:[^&gt;"']|"[^"]*"|'[^']*')+?\sclass\s*=3D\s*("[^"]*"|'[^']*')</pre=
>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>["'\s]my-class["'\s]</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>(?:^|\s)my-class(?:\s|$)</pre>
<p>Regex options: None<br>
Regex flavors: .NET, Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>9.8. Add a cellspacing Attribute to &lt;table&gt; Tags That Do Not
    Already Include It</h2>
<h3>Solution</h3>
<h4>Solution 1, simplistic</h4>
<pre>&lt;table\b(?![^&gt;]*?\scellspacing\b)([^&gt;]*)&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;table \b            # Match "&lt;table", as a complete word
(?!                  # Not followed by:
  [^&gt;]*?             #   Any attributes, etc.
  \s cellspacing \b  #   "cellspacing", as a complete word
)
([^&gt;]*)              # Capture attributes, etc. to backreference 1
&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Solution 2, more reliable</h4>
<pre>&lt;table\b(?!(?:[^&gt;"']|"[^"]*"|'[^']*')*?\scellspacing\b)((?:[^&gt=
;"']|"[^"]*"|'[^']*')*)&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;table \b  # Match "&lt;table", as a complete word
(?!  # Not followed by: Any attributes, etc., then "cellspacing"
  (?:[^&gt;"']|"[^"]*"|'[^']*')*?
  \s cellspacing \b
)
(  # Capture attributes, etc. to backreference 1
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
)
&gt;</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Insert the new attribute</h4>
<pre>&lt;table cellspacing=3D"0"$1&gt;</pre>
<pre>&lt;table cellspacing=3D"0"\1&gt;</pre>
<h2>9.9. Remove XML-Style Comments</h2>
<h3>Solution</h3>
<pre>&lt;!--.*?--&gt;</pre>
<p>Regex options: Dot
        matches line breaks<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;!--[\s\S]*?--&gt;</pre>
<p>Regex options: None<br>
</p><h3>Discussion</h3>
<h4>When comments can=E2=80=99t be removed</h4>
<pre>&lt;(script|style|textarea|title|xmp)\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&=
gt;.*?&lt;/\1\s*&gt;|&lt;plaintext\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;.*|&l=
t;[a-z](?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;|&lt;!\[CDATA\[.*?]]&gt;</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre># Special element: tag and its content
&lt;( script | style | textarea | title | xmp )\b
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
&gt; .*? &lt;/\1\s*&gt;
|
# &lt;plaintext/&gt; continues until the end of the string
&lt;plaintext\b
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
&gt; .*
|
# Standard element: tag only
&lt;[a-z]  # Tag name initial character
  (?:[^&gt;"']|"[^"]*"|'[^']*')*
&gt;
|
# CDATA section
&lt;!\[CDATA\[ .*? ]]&gt;</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;(script|style|textarea|title|xmp)\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&=
gt;[\s\S]*?&lt;/\1\s*&gt;|&lt;plaintext\b(?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;=
[\s\S]*|&lt;[a-z](?:[^&gt;"']|"[^"]*"|'[^']*')*&gt;|&lt;!\[CDATA\[[\s\S]*?]=
]&gt;</pre>
<p>Regex options: Case
          insensitive<br>
</p><h3>Variations</h3>
<h4>Find valid XML comments</h4>
<pre>&lt;!--[^-]*(?:-[^-]+)*--\s*&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>&lt;!--(?&gt;-?[^-]+)*--\s*&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, PCRE, Perl, Ruby</p>
<h4>Find valid HTML comments</h4>
<pre>&lt;!--(?!-?&gt;)[^-]*(?:-[^-]+)*--&gt;</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>9.10. Find Words Within XML-Style Comments</h2>
<h3>Problem</h3>
<pre>        This "TODO" is not within a comment, but the next one is. &lt;=
!--=20
        TODO
        : Come up with a cooler comment for this example. --&gt;</pre>
<h3>Solution</h3>
<h4>Two-step approach</h4>
<pre>&lt;!--.*?--&gt;</pre>
<p>Regex options: Dot
          matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>&lt;!--[\s\S]*?--&gt;</pre>
<p>Regex options: None<br>
</p><pre>\bTODO\b</pre>
<p>Regex options: Case
          insensitive<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Single-step approach</h4>
<pre>\bTODO\b(?=3D(?:(?!&lt;!--).)*?--&gt;)</pre>
<p>Regex options: Case
          insensitive, dot matches line breaks<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<pre>\bTODO\b(?=3D(?:(?!&lt;!--)[\s\S])*?--&gt;)</pre>
<p>Regex options: Case
          insensitive<br>
</p><h3>Discussion</h3>
<h4>Single-step approach</h4>
<pre>\b TODO \b      # Match the characters "TODO", as a complete word
(?=3D             # Followed by:
  (?:           #   Group but don't capture:
    (?! &lt;!-- )  #     Not followed by: "&lt;!--"
    .           #     Match any single character
  )*?           #   Repeat zero or more times, as few as possible (lazy)
  --&gt;           #   Match the characters "--&gt;"
)</pre>
<p>Regex options: Dot
          matches line breaks, free-spacing<br>
Regex flavors: .NET,
          Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>(?&lt;=3D&lt;!--(?:(?!--&gt;).)*?)\bTODO\b(?=3D(?:(?!&lt;!--).)*?--&gt=
;)</pre>
<p>Regex options: Case
        insensitive, dot matches line breaks<br>
</p><h2>9.11. Change the Delimiter Used in CSV Files</h2>
<h3>Solution</h3>
<pre>(,|\r?\n|^)([^",\r\n]+|"(?:[^"]|"")*")?</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>( , | \r?\n | ^ )   # Capture the leading field delimiter to backref 1
(                   # Capture a single field to backref 2:
  [^",\r\n]+        #   Unquoted field
|                   #  Or:
  " (?:[^"]|"")* "  #   Quoted field (may contain escaped double quotes)
)?                  # The group is optional because fields may be empty</pr=
e>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Example web page with JavaScript</h4>
<pre>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Change CSV delimiters from commas to tabs&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;Input:&lt;/p&gt;
&lt;textarea id=3D"input" rows=3D"5" cols=3D"75"&gt;&lt;/textarea&gt;

&lt;p&gt;&lt;input type=3D"button" value=3D"Replace" onclick=3D"commasToTab=
s()"&gt;&lt;/p&gt;

&lt;p&gt;Output:&lt;/p&gt;
&lt;textarea id=3D"output" rows=3D"5" cols=3D"75"&gt;&lt;/textarea&gt;

&lt;script&gt;
function commasToTabs() {
    var input  =3D document.getElementById("input"),
        output =3D document.getElementById("output"),
        regex  =3D /(,|\r?\n|^)([^",\r\n]+|"(?:[^"]|"")*")?/g,
        result =3D "",
        match;

    while (match =3D regex.exec(input.value)) {
        // Check the value of backreference 1
        if (match[1] =3D=3D ",") {
            // Add a tab (in place of the matched comma) and backreference
            // 2 to the result. If backreference 2 is undefined (because
            // the optional, second capturing group did not participate in
            // the match), use an empty string instead.
            result +=3D "\t" + (match[2] || "");
        } else {
            // Add the entire match to the result
            result +=3D match[0];
        }

        // If there is an empty match, prevent some browsers from getting
        // stuck in an infinite loop
        if (match.index =3D=3D regex.lastIndex) {
            regex.lastIndex++;
        }
    }

    output.value =3D result;
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<h2>9.12. Extract CSV Fields from a Specific Column</h2>
<h3>Solution</h3>
<pre>(,|\r?\n|^)([^",\r\n]+|"(?:[^"]|"")*")?</pre>
<p>Regex options: None<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>( , | \r?\n | ^ )   # Capture the leading field delimiter to backref 1
(                   # Capture a single field to backref 2:
  [^",\r\n]+        #   Unquoted field
|                   #  Or:
  " (?:[^"]|"")* "  #   Quoted field (may contain escaped double quotes)
)?                  # The group is optional because fields may be empty</pr=
e>
<p>Regex options: Free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h4>Example web page with JavaScript</h4>
<pre>&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Extract the third column from a CSV string&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;p&gt;Input:&lt;/p&gt;
&lt;textarea id=3D"input" rows=3D"5" cols=3D"75"&gt;&lt;/textarea&gt;

&lt;p&gt;&lt;input type=3D"button" value=3D"Extract Column 3"
    onclick=3D"displayCsvColumn(2)"&gt;&lt;/p&gt;

&lt;p&gt;Output:&lt;/p&gt;
&lt;textarea id=3D"output" rows=3D"5" cols=3D"75"&gt;&lt;/textarea&gt;

&lt;script&gt;
function displayCsvColumn(index) {
    var input =3D document.getElementById("input"),
        output =3D document.getElementById("output"),
        columnFields =3D getCsvColumn(input.value, index);

    if (columnFields.length &gt; 0) {
        // Show each record on its own line, separated by a line feed (\n)
        output.value =3D columnFields.join("\n");
    } else {
        output.value =3D "[No data found to extract]";
    }
}

// Return an array of CSV fields at the provided, zero-based index
function getCsvColumn(csv, index) {
    var regex =3D /(,|\r?\n|^)([^",\r\n]+|"(?:[^"]|"")*")?/g,
        result =3D [],
        columnIndex =3D 0,
        match;

    while (match =3D regex.exec(csv)) {
        // Check the value of backreference 1. If it's a comma,
        // increment columnIndex. Otherwise, reset it to zero.
        if (match[1] =3D=3D ",") {
            columnIndex++;
        } else {
            columnIndex =3D 0;
        }
        if (columnIndex =3D=3D index) {
            // Add the field (backref 2) at the end of the result array
            result.push(match[2]);
        }

        // If there is an empty match, prevent some browsers from getting
        // stuck in an infinite loop
        if (match.index =3D=3D regex.lastIndex) {
            regex.lastIndex++;
        }
    }

    return result;
}
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<h3>Variations</h3>
<h4>Match a CSV record and capture the field in column 1 to
        backreference 1</h4>
<pre>^([^",\r\n]+|"(?:[^"]|"")*")?(?:,(?:[^",\r\n]+|"(?:[^"]|"")*")?)*</pre=
>
<p>Regex options: ^ and
          $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Match a CSV record and capture the field in column 2 to
        backreference 1</h4>
<pre>^(?:[^",\r\n]+|"(?:[^"]|"")*")?,([^",\r\n]+|"(?:[^"]|"")*")?(?:,(?:[^"=
,\r\n]+|"(?:[^"]|"")*")?)*</pre>
<p>Regex options: ^ and
          $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Match a CSV record and capture the field in column 3 or higher
        to backreference 1</h4>
<pre>^(?:[^",\r\n]+|"(?:[^"]|"")*")?(?:,(?:[^",\r\n]+|"(?:[^"]|"")*")?){1},=
([^",\r\n]+|"(?:[^"]|"")*")?(?:,(?:[^",\r\n]+|"(?:[^"]|"")*")?)*</pre>
<p>Regex options: ^ and
          $ match at line breaks<br>
Regex flavors: .NET,
          Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h4>Replacement string</h4>
<pre>$1</pre>
<pre>\1</pre>
<h2>9.13. Match INI Section Headers</h2>
<h3>Solution</h3>
<pre>^\[[^\]\r\n]+]</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h3>Variations</h3>
<pre>^\[Section1]</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<h2>9.14. Match INI Section Blocks</h2>
<h3>Solution</h3>
<pre>^\[[^\]\r\n]+](?:\r?\n(?:[^[\r\n].*)?)*</pre>
<p>Regex options: ^ and $
        match at line breaks (=E2=80=9Cdot matches line breaks=E2=80=9D mus=
t not be
        set)<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^ \[ [^\]\r\n]+ ]  # Match a section header
(?:                # Followed by the rest of the section:
  \r?\n            #   Match a line break character sequence
  (?:              #   After each line starts, match:
    [^[\r\n]       #     Any character except "[" or a line break character
    .*             #     Match the rest of the line
  )?               #   The group is optional to allow matching empty lines
)*                 # Continue until the end of the section</pre>
<p>Regex options: ^ and $
        match at line breaks, free-spacing (=E2=80=9Cdot matches line break=
s=E2=80=9D must not
        be set)<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>
<h3>Discussion</h3>
<pre>[Section1]
Item1=3DValue1
Item2=3D[Value2]

; [SectionA]
; The SectionA header has been commented out

ItemA=3DValueA ; ItemA is not commented out, and is part of Section1

[Section2]
Item3=3DValue3
Item4 =3D Value4</pre>
<h2>9.15. Match INI Name-Value Pairs</h2>
<h3>Solution</h3>
<pre>^([^=3D;\r\n]+)=3D([^;\r\n]*)</pre>
<p>Regex options: ^ and $
        match at line breaks<br>
Regex flavors: .NET,
        Java, JavaScript, PCRE, Perl, Python, Ruby</p>
<pre>^               # Start of a line
( [^=3D;\r\n]+ )  # Capture the name to backreference 1
=3D               # Name-value delimiter
( [^;\r\n]* )   # Capture the value to backreference 2</pre>
<p>Regex options: ^ and $
        match at line breaks, free-spacing<br>
Regex flavors: .NET,
        Java, XRegExp, PCRE, Perl, Python, Ruby</p>

</body></html>
------=_NextPart_000_85C4_171F3A12.F33F8D90--
